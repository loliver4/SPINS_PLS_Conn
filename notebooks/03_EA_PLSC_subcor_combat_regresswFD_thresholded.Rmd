---
title: "02_EA_PLSC_subcor_combat_regress_thresholded"
output: html_notebook
editor_options:
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(splitstackshape)
library(plyr)
library(dplyr)
library(tidyr)
library(corrr)
library(psych)
library(Hmisc)
library(TExPosition)
library(data4PCCAR)
library(PTCA4CATA)
library(tableone)
library(corrplot)
library(mice)
library(ggplot2)
library(stringr)

```

```{r}
# set working dir
setwd("/scratch/loliver/SPINS_PLS_Conn")

# find EA residual time series files # pattern glob2rx("sub*_EA_2mm_noGSR_glasser_tian_meants.csv") 
files_EA_resid_ts <- list.files(path= ".", recursive=T, full.names=F, pattern="^sub.*_EA_2mm_noGSR_glasser_tian_meants\\.csv$") 

# confirm csvs aren't empty
files_EA_resid_ts[file.size(files_EA_resid_ts) == 0]

# create list of IDs
ptlist <- paste("SPN01", substring(files_EA_resid_ts,5,7), substring(files_EA_resid_ts,8,11), sep = "_")

# read in time series files
resid_ts <- lapply(files_EA_resid_ts, read.csv, header=F)

# transpose dfs
resid_ts <- lapply(resid_ts, t)

# Name dfs with participant IDs # N=438
names(resid_ts) <- ptlist

```

```{r}
# read in new inclusion list based on EA task, motion, and imaging (fmriprep and ciftify) QC (see /projects/loliver/QC/SPINS_EA_Exclusion.R)
# also checked old participants.tsv file to make sure nothing being missed
include_list <- read.csv(file="/projects/loliver/QC/SPINS_EA_QC_fMRI_inclusion_list.csv", header=F)

resid_ts <- resid_ts[names(resid_ts) %in% include_list$V1] # N=360

```

```{r}
# find circles onsets for each participant - these were increased by 1 s due to the slice timing change
setwd("/scratch/loliver/SPINS_PLS_Conn")
files_circles <- list.files(path= ".", recursive=T, full.names=F, pattern="^.*_circles\\.1D$")

# create list of IDs
circ_ptlist <- paste("SPN01", substring(files_circles,5,7), substring(files_circles,8,11), sep = "_")

# read in circles files
circles <- lapply(files_circles, read.csv, header=F, sep=" ", colClasses=c(NA, NA, "NULL"))
names(circles) <- circ_ptlist

# get circles onset times into same row, adding 546 s per run (273 TRs/run), dividing by 2 as TRs are 2s, and adding 1 s due to slice timing correction being from middle of TR in fmriprep
circles_times <- list()

for (i in names(circles)) {
  circles_times[[i]] <- round(((cbind(circles[[i]][1,],(circles[[i]][2,])+546,(circles[[i]][3,])+1092))/2)+1)
}

# remove circles from time series data (circles runs are 20 TRs or 40 s - this way we are removing 20 TRs - the onset + 19)
ea_resid_ts <- list()

for (i in names(resid_ts)) {
  ea_resid_ts[[i]] <- resid_ts[[i]][-c(circles_times[[i]][1,1]:(circles_times[[i]][1,1]+19),circles_times[[i]][1,2]:(circles_times[[i]][1,2]+19),
                         circles_times[[i]][1,3]:(circles_times[[i]][1,3]+19),circles_times[[i]][1,4]:(circles_times[[i]][1,4]+19),
                         circles_times[[i]][1,5]:(circles_times[[i]][1,5]+19),circles_times[[i]][1,6]:(circles_times[[i]][1,6]+19)),]
}


# check dims
#lapply(ea_resid_ts, dim)

# check for NAs
#for (i in names(ea_resid_ts)) {
#  print (i)
#  print(which(is.na(ea_resid_ts[[i]])))
#}

```

```{r}
# read in behavioural data for those with cognitive data (IDs have been changed for those with repeated scans, scanner variable updated, and EA scores added) - N=456
spins_behav <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_data_cog_09-12-2023.csv", header = T, stringsAsFactors = F)

# keep only participants we have EA connectivity data for - N=357
spins_behav_conn <- spins_behav[spins_behav$record_id %in% names(ea_resid_ts),]

# ZHP_0110 and ZHP_0172 did not complete multiple soc cog tasks - exclude these participants - N=355 
spins_behav_conn <- spins_behav_conn[spins_behav_conn$record_id!="SPN01_ZHP_0110" & spins_behav_conn$record_id!="SPN01_ZHP_0172",]

# run if want to remove the additional 2 participants in the EA sample who don't have RS data - N=353
spins_behav_conn <- spins_behav_conn[spins_behav_conn$record_id!="SPN01_MRC_0046" & spins_behav_conn$record_id!="SPN01_ZHH_0034",]

#write.csv(spins_behav_conn, file="/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_ea_conn_09-19-2023.csv", row.names=F)

# keep EA data from same sample 
ea_resid_ts <- ea_resid_ts[names(ea_resid_ts) %in% spins_behav_conn$record_id]

```

```{r}
# read in Tian and Glasser ROI labels (392)
rois <- read.csv(file = "/projects/loliver/SPINS_PLS_Conn/data/parcellations/Glasser_Tian_roi_info.csv", header=T)

# read in Alcala-Lopez et al. (2018) soc cog Glasser ROIs
# sc_rois <- read.csv(file = "/projects/loliver/SPINS_PLS_Conn/data/parcellations/Glasser_Alcala-Lopez_scog_rois.csv", header=F)

# add labels to df columns # dashes in roi names become dots here
for (i in names(ea_resid_ts)) {
  colnames(ea_resid_ts[[i]]) <- as.vector(rois$atlas_roi)
  ea_resid_ts[[i]] <- data.frame(ea_resid_ts[[i]])
}

# Generate correlation matrices for each participant 
ea_cor <- lapply(ea_resid_ts, correlate)

# set upper triangle to NA
ea_cor <- lapply(ea_cor, shave)

# example corr plot
rplot(ea_cor[[1]])
#rplot(ea_cor[[1]][rois_netorder$orig_order,c("term",rois_netorder$forced_name)])

# create dfs with corrs for each participant
ea_cor_str <- lapply(ea_cor, stretch, na.rm=F)
ea_cor_stru <- lapply(ea_cor_str, unite, col="rois", 1:2, sep="-", remove=T)
ea_cor_df <- lapply(ea_cor_stru, data.frame)

# change col 1 to row names
cor_names <- as.vector(ea_cor_df[[1]][,1])

for (i in names(ea_cor_df)) {
  ea_cor_df[[i]] <- data.frame(ea_cor_df[[i]][,2])
  ea_cor_df[[i]] <- t(ea_cor_df[[i]])
  colnames(ea_cor_df[[i]]) <- cor_names
}

# bind rows across df list to generate tibble with all corrs for each participant
ea_corrs <- do.call("rbind",ea_cor_df)
rownames(ea_corrs) <- names(ea_cor_df)

# remove columns with only NAs
ea_corrs <- ea_corrs[,colSums(is.na(ea_corrs)) != nrow(ea_corrs)]

# fisher z transform corrs
ea_corrs_z  <- fisherz(ea_corrs)

```

```{r}
# impute missing values for combat variables 
#spins_behav_combat <- spins_behav_conn[,c("record_id","scanner","diagnostic_group","demo_sex","demo_age_study_entry",
#          "scog_rmet_total","scog_er40_total","scog_mean_ea","scog_tasit1_total","scog_tasit2_sinc",
#          "scog_tasit2_simpsar","scog_tasit2_parsar","scog_tasit3_lie","scog_tasit3_sar",
#          "np_domain_tscore_process_speed","np_domain_tscore_att_vigilance","np_domain_tscore_work_mem",
#          "np_domain_tscore_verbal_learning","np_domain_tscore_visual_learning","np_domain_tscore_reasoning_ps")]

# explore rows with NAs - 9 people missing any beh values
#check <- spins_behav_combat[!complete.cases(spins_behav_combat),] 

# impute remaining NA values using mice (1 each for 9 participants, aside from SPN01_ZHP_0140 missing tasit 3 lies and sar)
# ppm (predictive mean matching) is default method; m = 5 is the default number of imputations
# logged events are related to the categorical variables (not included in imputation)
#spins_behav_combat <- complete(mice(spins_behav_combat))

#spins_behav_combat[spins_behav_combat$record_id %in% check$record_id,]

# write out behav data with imputed values
#write.csv(spins_behav_combat, file="/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_ea_combat_09-19-2023.csv", row.names=F)

# read in variables for combat with imputed data for missing values using mice 
spins_behav_combat <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_ea_combat_09-19-2023.csv", header = T, stringsAsFactors = F)

```

```{r}
# run ComBat on connectivity data to harmonize across scanners
library(neuroCombat)

# dat is a data matrix of the data to harmonize - rows are features (connections) and columns are participants
ea_corrs_com <- as.matrix(t(ea_corrs_z[rownames(ea_corrs_z) %in% spins_behav_combat$record_id,]))

# mod is a design matrix specifying biological covariates that should be protected - here diagnosis, age, sex, and cog variables
modcombat <- model.matrix(~ diagnostic_group + demo_sex + demo_age_study_entry +
          scog_rmet_total + scog_er40_total + scog_mean_ea + scog_tasit1_total + scog_tasit2_sinc + 
          scog_tasit2_simpsar + scog_tasit2_parsar + scog_tasit3_lie + scog_tasit3_sar + 
          np_domain_tscore_process_speed + np_domain_tscore_att_vigilance + np_domain_tscore_work_mem + 
          np_domain_tscore_verbal_learning + np_domain_tscore_visual_learning + np_domain_tscore_reasoning_ps, data=spins_behav_combat)

# R run ComBat
# batch is a vector (length should be equal to the number of columns in the data matrix) that specifies the id for the batch, site, or scanner to correct for
ea_combat <- neuroCombat(dat=ea_corrs_com, batch=c(spins_behav_combat$scanner), mod=modcombat)

# transpose the harmonized data matrix 
ea_combat_data <- t(ea_combat$dat.combat)

```

```{r}
# regress age, sex, mean FD out of conn and behav metrics before running PLS (based on associations with these vars)

# read in rs mean FD data
spins_fd <- read.csv(file="/projects/loliver/QC/spins_mean_fd_per_run.csv",stringsAsFactors=F,header=T)

# behav data
spins_behav_combat_reg <- merge(spins_behav_combat,spins_fd[,c("record_id","fd_mean.task.emp_bold")],by="record_id")

spins_behav_combat_reg[,6:20] <- apply(spins_behav_combat_reg[,6:20], 2, function(x) lm(x ~ spins_behav_combat_reg$demo_age_study_entry + spins_behav_combat_reg$demo_sex + spins_behav_combat_reg$fd_mean.task.emp_bold)$residual)

spins_behav_combat <- spins_behav_combat_reg

# conn data
ea_combat_data_reg <- data.frame(ea_combat_data)
ea_combat_data_reg$demo_age_study_entry <- spins_behav_combat$demo_age_study_entry
ea_combat_data_reg$demo_sex <- spins_behav_combat$demo_sex
ea_combat_data_reg$fd_mean.task.emp_bold <- spins_behav_combat_reg$fd_mean.task.emp_bold

ea_combat_data_reg[,1:76636] <- apply(ea_combat_data_reg[,1:76636], 2, function(x) lm(x ~ ea_combat_data_reg$demo_age_study_entry +  ea_combat_data_reg$demo_sex + ea_combat_data_reg$fd_mean.task.emp_bold)$residual)

ea_combat_data_reg <- ea_combat_data_reg[,1:76636]

ea_combat_data <- ea_combat_data_reg

```

```{r}
#save.image(file = "/projects/loliver/SPINS_PLS_Conn/notebooks/EA_PLSC_subcor_combat_regresswFD_thresholded.RData")

```

```{r warning=FALSE}
# PLSC (Derek Beaton's pkg; symmetric analysis as per McIntosh et al., 1996)

# identify top 10% most variable connections as measured by median absolute deviation to reduce number of connectivity inputs (more robust against outliers than standard deviation as per Xia et al., 2018)
mad_conn <- apply(ea_combat_data, 2, mad)

# 76636*.1 = 7664
top_10 <- names(sort(mad_conn, decreasing=TRUE)[1:7664])

# create separate X and Y matrices 
conn_top_10 <- colnames(ea_combat_data[,colnames(ea_combat_data) %in% top_10])
conn <- as.matrix(ea_combat_data[,colnames(ea_combat_data) %in% top_10]) # x var

beh <- as.matrix(spins_behav_combat[,c("scog_rmet_total","scog_er40_total","scog_mean_ea","scog_tasit1_total","scog_tasit2_sinc",
          "scog_tasit2_simpsar","scog_tasit2_parsar","scog_tasit3_lie","scog_tasit3_sar",
          "np_domain_tscore_process_speed","np_domain_tscore_att_vigilance","np_domain_tscore_work_mem",
          "np_domain_tscore_verbal_learning","np_domain_tscore_visual_learning","np_domain_tscore_reasoning_ps")]) # y var
rownames(beh) <- spins_behav_combat$record_id
colnames(beh) <- c("RMET","ER40","EA","TASIT1","T2_sinc","T2_simsar","T2_parsar","T3_lie","T3_sar","Proc_Speed","Att_Vig","Work_Mem",
"Verb_Learn","Vis_Learn","Reason_PS") 

conn <- conn[rownames(conn) %in% rownames(beh),]

# generate table one - with imputed values
char_table <- spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry","scog_rmet_total","scog_er40_total",
          "scog_mean_ea","scog_tasit1_total","scog_tasit2_sinc","scog_tasit2_simpsar","scog_tasit2_parsar","scog_tasit3_lie","scog_tasit3_sar",
          "np_domain_tscore_process_speed","np_domain_tscore_att_vigilance","np_domain_tscore_work_mem",
          "np_domain_tscore_verbal_learning","np_domain_tscore_visual_learning","np_domain_tscore_reasoning_ps")]
#char_table <- na.omit(char_table)
colnames(char_table) <- c("record_id","Diagnostic_Group","Sex_at_birth","Age","RMET","ER40","EA","TASIT1","T2_sinc","T2_simsar","T2_parsar",
                          "T3_lie","T3_sar","Proc_Speed","Att_Vig","Work_Mem","Verb_Learn","Vis_Learn","Reason_PS") 

table_one <- CreateTableOne(strata="Diagnostic_Group",data=char_table[,2:19])
table <- print(table_one)

#write.csv(table,file="/projects/loliver/SPINS_PLS_Conn/data/processed/tableone_ea_rs_imp_09-19-2023.csv")

char_table_clin <- merge(char_table,spins_behav_conn[,c("record_id","wtar_std_score","bprs_factor_total","sans_total_sc","qls_total","bsfs_total")],by="record_id")

table_one_clin <- CreateTableOne(strata="Diagnostic_Group",data=char_table_clin[,2:24])
table_clin <- print(table_one_clin)

#write.csv(table_clin,file="/projects/loliver/SPINS_PLS_Conn/data/processed/tableone_ea_rs_imp_clin_09-19-2023.csv")

# examine covariance - maybe after so we can focus on most relevant variables
# ea_cbind(beh,conn)
#library(eqs2lavaan)
#beh_cor <- cor(beh)
#beh_cov <- cov(beh)
#corrplot(beh_cor,method="circle",tl.cex=.9,tl.col="black",type="upper")
#plotCov(beh_cov)  # looks terrible

```

```{r warning=FALSE, fig.height=6, fig.width=6}
# run pls - include scaling as these variables have not been z-scored
# per behavioural PLS in MATLAB (centered and normalized with sum of squares of each column equal to 1)
ea_plsc <- tepPLS(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=NULL, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_plsc <- perm4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000) 

# plot scree
PlotScree(ev = ea_plsc$TExPosition.Data$eigs, p.ev = perm_ea_plsc$pEigenvalues, plotKaiser = TRUE, col.ns = "black",
          col.sig = "red")

ea_plsc$TExPosition.Data$t # to get variance explained
perm_ea_plsc$pOmnibus # check omnibus test
perm_ea_plsc$pEigenvalues # to get LV p values

```

```{r}
# run permutation for second eigenvalue
# Ju-Chi's code to regress out effects from first latent component/dimension to then check for second

lx1 <- as.matrix(ea_plsc$TExPosition.Data$lx[,1])
ly1 <- ea_plsc$TExPosition.Data$ly[,1]

X.proc <- expo.scale(conn, center = TRUE, scale = "SS1") # what you originally do for center1 and scale1 (TRUE and "SS1" are the default setting of tepPLS)
Y.proc <- expo.scale(beh, center = TRUE, scale = "SS1") # what you originally do for center2 and scale2 (TRUE and "SS1" are the default setting of tepPLS)

# regress Lx and Ly from X and Y
Xhat <- lm(X.proc~lx1)$residuals
Yhat <- lm(Y.proc~ly1)$residuals

set.seed(999)
pls.inf2 <- data4PCCAR::perm4PLSC(Xhat, Yhat, 
                                 center1 = FALSE, scale1 = FALSE, 
                                 center2 = FALSE, scale2 = FALSE, 
                                 nIter = 1000)

# check if the model is significant overall # changed 'f's to 'p's
# if this is not significant, your analysis is really unidimensional
pls.inf2$pOmnibus

# check if the first eigenvalue is significant - it is (p=.02)
pls.inf2$pEigenvalues

```

```{r warning=FALSE, fig.height=4, fig.width=5}
# plot scores (latent variables, or latent variable scores)
LV1 <- cbind(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1])
colnames(LV1) <- c("Connectivity Latent Variable Scores", "Behavior Latent Variable Scores")
plot_LV1 <- createFactorMap(LV1, col.axes="black", col.background="white", title="EA Dimension 1 Correlation between Latent Variables") 

cor.test(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1]) # .322, p < .0001
plot_LV1$zeMap_background + plot_LV1$zeMap_dots + coord_cartesian()  # coord_cartesian stops plot 1:1 ratio


LV2 <- cbind(ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2])
colnames(LV2) <- c("Connectivity Latent Variable Scores", "Behavior Latent Variable Scores")
plot_LV2 <- createFactorMap(LV2, col.axes="black", col.background="white", title="EA Dimension 2 Correlation between Latent Variables") 

cor.test(ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2]) # .401, p < .0001
plot_LV2$zeMap_background + plot_LV2$zeMap_dots + coord_cartesian() 

```

```{r}
# component plots
factor <- rbind(ea_plsc$TExPosition.Data$fi, ea_plsc$TExPosition.Data$fj)
contributions <- rbind(ea_plsc$TExPosition.Data$ci, ea_plsc$TExPosition.Data$cj) # contribution reflected by size

# component plots with factor scores
#prettyPlot(factor, 
#           contributionCircles = TRUE,
#           contributions=contributions,
#           xlab='Component 1',
#           ylab='Component 2',
#           main='Component plot',
#           dev.new=F) #required so doesn't print list

# x connectivity set only
#prettyPlot(ea_plsc$TExPosition.Data$fi, 
#           contributionCircles = TRUE,
#           contributions=ea_plsc$TExPosition.Data$ci,
#           xlab='Component 1',
#           ylab='Component 2',
#           main='Component map X set', 
#           dev.new = F)

# y behavioural set only # can see some separation of soc and non-soc cog in component 2
prettyPlot(ea_plsc$TExPosition.Data$fj, 
           contributionCircles = TRUE,
           contributions=ea_plsc$TExPosition.Data$cj,
           xlab='Component 1',
           ylab='Component 2',
           main='Component map Y set', 
           dev.new = F)

```

```{r warning=FALSE}
# bootstrapping for contributor significance # critical val of 2.58 (alpha < .01 two-sided)
# bootstrapped model 
set.seed(999)
ea_plsc_boot <- Boot4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000,
  critical.value = 2.6, nf2keep = 3) 

BR_conn <- ea_plsc_boot$bootRatios.i
BR_beh <- ea_plsc_boot$bootRatios.j

# sig conn for LC1 # 2125 w 2.6  
length(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))
#names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))

# sig beh for LC1  # 12 w 2.6
names(which(ea_plsc_boot$bootRatiosSignificant.j[,1] == TRUE))

# sig conn for LC2 # 232 w 2.6  
length(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))
#names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))

# sig beh for LC2 # 4 w 2.6
names(which(ea_plsc_boot$bootRatiosSignificant.j[,2] == TRUE))

```

```{r fig.height=6, fig.width=6}
# contribution plots
# contributions are absolute values, so need to get signs based on factor scores
Cx_conn <- ea_plsc$TExPosition.Data$ci * sign(ea_plsc$TExPosition.Data$fi)
Cy_beh <- ea_plsc$TExPosition.Data$cj * sign(ea_plsc$TExPosition.Data$fj)

# plot top 25 contributing conn vars 
top_25 <- names(sort(Cx_conn[,1], decreasing=TRUE)[1:25])
Cx_conn_top_25 <- Cx_conn[top_25,1]

cont_conn_plot_LC1  <- PrettyBarPlot2(
            bootratio = round(100000*Cx_conn_top_25), 
            threshold = 100000*(1/nrow(Cx_conn)),
            color4ns = "gray75", 
            #signifOnly = TRUE,
            plotnames = TRUE,
            main = 'EA Dimension 1: Contributions - Connectivity',
            ylab = 'Signed Contributions')

print(cont_conn_plot_LC1)

# Variables that contribute more than average (i.e., with a big enough effect size) are considered important (https://herveabdi.github.io/R4SPISE2022/articles/C1_PLSConWines.html#circles-of-correlations)
# When the variables are centered and scaled to have their sums of squares=1, each variable contributes one unit of variance; therefore, the average contribution is 1/(# of variables of the table)

cont_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = round(100*Cy_beh[,1]),
  threshold = 100*(1/15), 
  #ylim=c(0, max(abs(100*Cy_beh[,1]))),
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE,
  #font.shrink = 0,
  #font.size = 5,
  main = 'EA Dimension 1: Contributions - Behavior',
  ylab = 'Signed Contributions') +
  scale_y_continuous(limits=c(0,13)) # ylim wasn't restricting the range +
#  theme(axis.text.y = element_text(size=18))

print(cont_beh_plot_LC1)

#LV2_Conn <- PrettyBarPlot2(bootratio = round(100*Cx_conn[,2]), 
#            plotnames = TRUE,
#            signifOnly = TRUE,
#            main = "Conn Factor Loadings LV2",
#            ylab = "Signed Contributions")

cont_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = round(100*Cy_beh[,2]),
  threshold = 100*(1/15),
  ylim=NULL,
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE,
  #font.shrink = 0,
  #font.size = 5,
  main = 'EA Dimension 2: Contributions - Behavior',
  ylab = 'Signed Contributions') #+
# theme(axis.text.y = element_text(size=18))

print(cont_beh_plot_LC2)

```

```{r}
# bootstrap ratio plots

# beh for LC1
br_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = BR_beh[,1], # for LC1 
  threshold = 2.6, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 1: Bootstrap Ratios - Behavior', 
  ylab = "Bootstrap Ratios")

print(br_beh_plot_LC1)

# beh for LC2
br_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = BR_beh[,2], # for LC2
  threshold = 2.6, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 2: Bootstrap Ratios - Behavior', 
  ylab = "Bootstrap Ratios")

print(br_beh_plot_LC2)

```

```{r warning=FALSE}
# salience plots 
sal_conn <- ea_plsc$TExPosition.Data$pdq$p
sal_beh <- ea_plsc$TExPosition.Data$pdq$q

# conn for LC1
sal_conn_plot_LC1 <- PrettyBarPlot2(
  bootratio = sal_conn[,1], # for LC1 
  threshold = 0, 
  ylim = NULL, 
  color.bar = c("mediumpurple4", "darkolivegreen4", "gray75"),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  main = 'EA Dimension 1: Saliences - Connectivity', 
  ylab = "Saliences")

# beh for LC1
sal_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = sal_beh[,1], # for LC1 
  threshold = 0, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 1: Saliences - Behavior', 
  ylab = "Saliences")

print(sal_beh_plot_LC1)

# conn for LC2
sal_conn_plot_LC2 <- PrettyBarPlot2(
  bootratio = sal_conn[,2], # for LC2
  threshold = 0, 
  ylim = NULL, 
  color.bar = c("mediumpurple4", "darkolivegreen4", "gray75"),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  main = 'EA Dimension 2: Saliences - Connectivity', 
  ylab = "Saliences")

# beh for LC2
sal_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = sal_beh[,2], # for LC2
  threshold = 0, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 2: Saliences - Behavior', 
  ylab = "Saliences")

print(sal_beh_plot_LC2)

```

```{r fig.height=4, fig.width=10}
# arrange LC1 and LC2 contribution and bootstrap ratio plots 
library(gridExtra)

# contributions and bootstrap ratios
grid.arrange(
    cont_beh_plot_LC1,
    br_beh_plot_LC1,
    ncol = 2,nrow = 1,
    top = "" #Behavior Contributions and Bootstrap Ratios EA Dimension 1"
  )

grid.arrange(
    cont_beh_plot_LC2,
    br_beh_plot_LC2,
    ncol = 2,nrow = 1,
    top = "" #Behavior Contributions and Bootstrap Ratios EA Dimension 2"
  )

```

```{r}
# tried alternative visualizations using R4SPISE2022 (PLSC on wines: https://herveabdi.github.io/R4SPISE2022/articles/C1_PLSConWines.html), but this pkg doesn't seem to be working accurately for me and I'm happy with the plots above

```

```{r fig.height=6, fig.width=8}
# Visualize conn findings - saliences
net_cols <- c("darkolivegreen4","darkorange","brown","red","orchid2","gold","darkcyan","chartreuse","magenta4","cyan","purple","blue","black")

# Generate matrices with salience values (loadings) for sig contributors for LV1
ea_conn_sal_LV1 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F) # changed from sep="-" - confirmed retaining correct # of ROIs

# change r values to saliences for significant connections - the saliences are small values, hence the x100 for visualization
# divided by 4 to limit the range between 0 and 1 for plot alpha - check range()
ea_conn_sal_LV1[ea_conn_sal_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 100*(sal_conn[rownames(sal_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/4

# make all other connections 0
ea_conn_sal_LV1[!(ea_conn_sal_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# visualize LV1 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_sal_LV1 <- as_tbl_graph(ea_conn_sal_LV1[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# swirly plot by network
ggraph(tg_ea_conn_sal_LV1, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_sal_LV1, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

```

```{r fig.height=6, fig.width=8}
# Visualize conn findings - signed contributions
# Generate matrices with contribution values for sig contributors for LV1 
ea_conn_LV1 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to contributions for significant connections - the contributions are very small values, hence the x10000 for visualization
# divided by 12 to limit the range between 0 and 1 for plot alpha - check range() # kept the same as orig (vs 11) as just for visualization and similar 
ea_conn_LV1[ea_conn_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 10000*(Cx_conn[rownames(Cx_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/12

# make all other connections 0
ea_conn_LV1[!(ea_conn_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# visualize LV1 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_LV1 <- as_tbl_graph(ea_conn_LV1[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r > 0.1087 ~ "pos", r < -0.1087 ~ "neg", r <= 0.1087 & r >= -0.1087 ~ "ns"), r=abs(r)) %>% 
  filter(val != "ns") # updated to filter out vars deemed important (those that contribute more than average: 10000*(1/nrow(Cx_conn))/12
# was mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns")

# swirly plot by lobe
ggraph(tg_ea_conn_LV1, layout="linear", sort.by=lobe) +
  geom_edge_arc(aes(colour=val),alpha=.2) + # width=r
  geom_node_point(aes(colour=lobe), size=4) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# by network
ggraph(tg_ea_conn_LV1, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_LV1, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 


#  scale_edge_alpha_continuous(range=c(0,1)) +
#  scale_edge_width_continuous(range = c(1,3))

#ggraph(tg_ea_conn_LV1) + 
#  geom_edge_link() + 
#  geom_node_point()

```

```{r fig.height=6, fig.width=8}
# Visualize conn findings - original mean conn values multiplied by contribution
# Generate matrices with conn x contribution values for sig contributors for LV1
# remove roi column before calculating means across matrices
mean_ea_cor <- lapply(ea_cor, "[", 1:392, 2:393)

# get mean corrs across participants 
mean_ea_cor <- aaply(laply(mean_ea_cor, as.matrix), c(2, 3), mean, na.rm=F)

# corr plot
#rplot(mean_ea_cor)

detach(package:plyr)

# convert to tibble, add back roi column, rearrange columns, and convert to cor_df object
mean_ea_cor <- as_tibble(mean_ea_cor)
mean_ea_cor$term <- colnames(mean_ea_cor)
mean_ea_cor <- mean_ea_cor[1:392,c(393,1:392)]
mean_ea_cor <- as_cordf(mean_ea_cor)

# create df with mean corrs across participants
mean_ea_cor_str <- stretch(mean_ea_cor, na.rm=F) # the NAs will get changed to 0s anyway
mean_ea_conn_df <- unite(mean_ea_cor_str, col="rois", 1:2, sep=".", remove=F)

```

```{r}
# visualize positive and negative loadings separately to retain pos vs neg orig connectivity - conn direction by contribution
library(tidygraph)
library(ggraph)

# only retain conn direction, not magnitude
#mean_ea_conn_dir <- mean_ea_conn_df %>% mutate(r = case_when(r>0 ~ 1, r<0 ~ -1, r==0 ~ 0))

# multiply conn by absolute contribution ($ci)
ea_conn_cont_LV1_abs <- mean_ea_conn_df

ea_conn_cont_LV1_abs[ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 10000*sign(ea_conn_cont_LV1_abs[ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"])*(ea_plsc$TExPosition.Data$ci[rownames(ea_plsc$TExPosition.Data$ci) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/12 

# make non-sig connections 0
ea_conn_cont_LV1_abs[!(ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# make negative loadings 0 to visualize positive loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV1_pos <- ea_conn_cont_LV1_abs
ea_conn_cont_LV1_pos[ea_conn_cont_LV1_pos$rois %in% names(which(Cx_conn[,1]<0.0001305)), "r"] <- 0 # was <0 

# make positive loadings 0 to visualize negative loadings only, and those above contribution threshold
ea_conn_cont_LV1_neg <- ea_conn_cont_LV1_abs
ea_conn_cont_LV1_neg[ea_conn_cont_LV1_neg$rois %in% names(which(Cx_conn[,1]>-0.0001305)), "r"] <- 0 # was >0

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_pos <- as_tbl_graph(ea_conn_cont_LV1_pos[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig and pos nodes
tg_ea_conn_cont_LV1_neg <- as_tbl_graph(ea_conn_cont_LV1_neg[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# orig mean connectivity values > .4 (not just sig)
tg_ea_conn_LV1_r <- as_tbl_graph(mean_ea_conn_df[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns") %>% filter(abs(r) > .4)

```

```{r fig.height=6, fig.width=8}
# orig mean conn values > .4
ggraph(tg_ea_conn_LV1_r, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r), alpha=.3) +  
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1)) +
  ggtitle("Connectivity") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# positive loadings
ggraph(tg_ea_conn_cont_LV1_pos, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  #scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

data.frame(ea_conn_cont_LV1_pos[order(ea_conn_cont_LV1_pos$r, decreasing = TRUE),])

# negative loadings
ggraph(tg_ea_conn_cont_LV1_neg, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

data.frame(ea_conn_cont_LV1_neg[order(ea_conn_cont_LV1_neg$r, decreasing = TRUE),])

```

```{r fig.height=12, fig.width=15}
# generate heatmap of saliences for sig contributors (just to see)   

# add forced roi names and orig order to roi df
rois$forced_name <- colnames(ea_cor[[1]][2:393])
rois$orig_order <- 1:392

# reorganize roi data frame based on Cole Anticevic networks
rois_netorder <- arrange(rois,net_order_ColeAnt)
rois_netorder$colour <- c(rep("red",6),rep("pink",4),rep("purple",7),rep("blue",77),rep("lightskyblue1",15),
              rep("green",50),rep("darkgreen",23),rep("yellow",23),rep("orange",56),rep("brown",39),
              rep("wheat",54),rep("grey",6),rep("black",32))  ## old colours still

# saliences sig only
ggplot(ea_conn_sal_LV1, aes(x=factor(y,levels=rois_netorder$forced_name),y=factor(x,levels=rois_netorder$forced_name),fill=r)) + 
  geom_tile() +
  scale_fill_gradient2(high = "#b2182b", mid = "white", low = "#2166ac", 
        midpoint = 0, limit = c(-1,1), name="Salience (sig only)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
        axis.text = element_text(size = 10, color=rois_netorder$colour)) 
  #ggtitle("Connectivity Change (T2-T1) in Remitters - Relapsers") + ylab("") + xlab("")

```

```{r}
# calculate mean within and between-network values for the contributions (sig only) - pos 
ea_conn_cont_LV1_pos_df <- data.frame(ea_conn_cont_LV1_pos)

# change duplicates to same value
ea_conn_cont_LV1_pos_dup <- data.frame(ea_conn_cont_LV1_pos[,2:4])
colnames(ea_conn_cont_LV1_pos_dup) <- c("y","x","r")
ea_conn_cont_LV1_pos_dup <- ea_conn_cont_LV1_pos_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV1_pos_dup <- ea_conn_cont_LV1_pos_dup[ea_conn_cont_LV1_pos_dup$r!=0,]

ea_conn_cont_LV1_pos_dup <- unite(ea_conn_cont_LV1_pos_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV1_pos_dup$rois) {
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$rois == i,"r"] <- ea_conn_cont_LV1_pos_dup[ea_conn_cont_LV1_pos_dup$rois == i, "r"]
}

# add forced roi names and orig order to roi df
rois$forced_name <- colnames(ea_cor[[1]][2:393])
rois$orig_order <- 1:392

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values 
ea_conn_cont_LV1_pos_nets <- ea_conn_cont_LV1_pos_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),  # [r!=0] get mean of sig values only
            count=n())

ea_conn_cont_LV1_pos_nets$to <- as.factor(ea_conn_cont_LV1_pos_nets$to)
ea_conn_cont_LV1_pos_nets$from <- as.factor(ea_conn_cont_LV1_pos_nets$from)
#ea_conn_cont_LV1_pos_nets$mean[is.nan(ea_conn_cont_LV1_pos_nets$mean)] <- 0 # change NaNs to 0s

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_pos_nets <- as_tbl_graph(ea_conn_cont_LV1_pos_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")  # activate(nodes) %>% 
  #mutate(to=as.factor(ea_conn_cont_LV1_pos_nets$to),from=as.factor(ea_conn_cont_LV1_pos_nets$from)) %>%


# calculate mean within and between-network values for contributions (sig only) - neg 
ea_conn_cont_LV1_neg_df <- data.frame(ea_conn_cont_LV1_neg)

# change duplicates to same value
ea_conn_cont_LV1_neg_dup <- data.frame(ea_conn_cont_LV1_neg[,2:4])
colnames(ea_conn_cont_LV1_neg_dup) <- c("y","x","r")
ea_conn_cont_LV1_neg_dup <- ea_conn_cont_LV1_neg_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV1_neg_dup <- ea_conn_cont_LV1_neg_dup[ea_conn_cont_LV1_neg_dup$r!=0,]

ea_conn_cont_LV1_neg_dup <- unite(ea_conn_cont_LV1_neg_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV1_neg_dup$rois) {
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$rois == i,"r"] <- ea_conn_cont_LV1_neg_dup[ea_conn_cont_LV1_neg_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values
ea_conn_cont_LV1_neg_nets <- ea_conn_cont_LV1_neg_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),
            count=n())
ea_conn_cont_LV1_neg_nets$to <- as.factor(ea_conn_cont_LV1_neg_nets$to)
ea_conn_cont_LV1_neg_nets$from <- as.factor(ea_conn_cont_LV1_neg_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_neg_nets <- as_tbl_graph(ea_conn_cont_LV1_neg_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")

```

```{r fig.height=6.5, fig.width=8}
# mean nets positive loadings (contribution)
nets_pos_LV1 <- ggraph(tg_ea_conn_cont_LV1_pos_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #, alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.25)) + 
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) +  #, alpha=.6
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_pos_LV1 + geom_node_text(aes(label=name,colour=name), show.legend=F, nudge_x=nets_pos_LV1$data$x*.4, nudge_y=nets_pos_LV1$data$y*.2) 

data.frame(ea_conn_cont_LV1_pos_nets[order(ea_conn_cont_LV1_pos_nets$mean, decreasing = TRUE),])

# mean nets negative loadings
nets_neg_LV1 <- ggraph(tg_ea_conn_cont_LV1_neg_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) +  #, alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) + # shape=15, 
  #geom_node_label(aes(label=name, colour=name), size = 6, show.legend=F) +
  #geom_node_text(aes(label=name),  colour='black', size=4,
  #                show.legend=FALSE, family="mono") +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.0025)) + # chnaged from .025
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) + #, alpha=.6
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_neg_LV1 + geom_node_text(aes(label=name,colour=name), show.legend=F, nudge_x=nets_neg_LV1$data$x*.4, nudge_y=nets_neg_LV1$data$y*.2) 

data.frame(ea_conn_cont_LV1_neg_nets[order(ea_conn_cont_LV1_neg_nets$mean, decreasing = TRUE),])

```

```{r, fig.height=5, fig.width=6}
# heatmap mean nets pos loadings (contribution)
ggplot(ea_conn_cont_LV1_pos_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "grey") +
  geom_tile(data = ea_conn_cont_LV1_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .25) +
  scale_fill_gradient(high = "#2166ac", low = "white", limit = c(0,.25), name="") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
        axis.text = element_text(size = 10, color=net_cols)) +
  ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

ggplot(ea_conn_cont_LV1_neg_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "grey") +
  geom_tile(data = ea_conn_cont_LV1_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .25) +
  scale_fill_gradient(high = "#2166ac", low = "white", limit = c(0,.0025), name="") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
        axis.text = element_text(size = 10, color=net_cols)) +
  ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

```




```{r fig.height=6, fig.width=8}
# LV2 saliences
# Generate matrices with salience values (loadings) for sig contributors for LV2
ea_conn_sal_LV2 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to saliences for significant connections - the salience are small values, hence the x100 for visualization
# divided by 4 to limit the range between 0 and 1 for plot alpha - check range()
ea_conn_sal_LV2[ea_conn_sal_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 100*(sal_conn[rownames(sal_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/4

# make all other connections 0
ea_conn_sal_LV2[!(ea_conn_sal_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# visualize LV2 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_sal_LV2 <- as_tbl_graph(ea_conn_sal_LV2[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# swirly plot by network
ggraph(tg_ea_conn_sal_LV2, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_sal_LV2, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

```

```{r fig.height=6, fig.width=8}
# LV2 signed contributions
ea_conn_LV2 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to saliences for significant connections # changed to 16
ea_conn_LV2[ea_conn_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 10000*(Cx_conn[rownames(Cx_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/16

# make all other connections 0
ea_conn_LV2[!(ea_conn_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# visualize LV2 conn results
# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
tg_ea_conn_LV2 <- as_tbl_graph(ea_conn_LV2[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r > 0.082 ~ "pos", r < -0.082 ~ "neg", r <= 0.082 & r >= -0.082 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")
# updated to filter out vars deemed important (those that contribute more than average: 10000*(1/nrow(Cx_conn))/16
# was mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns")

# swirly plot by network
ggraph(tg_ea_conn_LV2, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=0.3) + 
  geom_node_point(aes(colour=Network), size = 2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() +  
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x  = element_blank(),
        axis.text.y  = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_LV2, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=0.3) +   #,curvature=sign(strength$r)
  geom_node_point(aes(colour=Network), size = 4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() +  
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x  = element_blank(),
        axis.text.y  = element_blank())  

```

```{r}
# generate matrices with conn x contribution values for sig contributors for LV2
# visualize positive and negative loadings separately to retain pos vs neg orig connectivity - contribution
library(tidygraph)
library(ggraph)

# multiply conn by absolute loading ($ci)
ea_conn_cont_LV2_abs <- mean_ea_conn_df
ea_conn_cont_LV2_abs[ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 10000*sign(ea_conn_cont_LV2_abs[ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"])*(ea_plsc$TExPosition.Data$ci[rownames(ea_plsc$TExPosition.Data$ci) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/16

# make non-sig connections 0
ea_conn_cont_LV2_abs[!(ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# make negative loadings 0 to visualize positive loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV2_pos <- ea_conn_cont_LV2_abs
ea_conn_cont_LV2_pos[ea_conn_cont_LV2_pos$rois %in% names(which(Cx_conn[,2]<0.0001305)), "r"] <- 0 # was <0

# make positive loadings  0 to visualize negative loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV2_neg <- ea_conn_cont_LV2_abs
ea_conn_cont_LV2_neg[ea_conn_cont_LV2_neg$rois %in% names(which(Cx_conn[,2]>-0.0001305)), "r"] <- 0 # was >0

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_pos <- as_tbl_graph(ea_conn_cont_LV2_pos[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig and pos nodes
tg_ea_conn_cont_LV2_neg <- as_tbl_graph(ea_conn_cont_LV2_neg[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

```

```{r fig.height=6, fig.width=8}
# positive loadings
ggraph(tg_ea_conn_cont_LV2_pos, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Positive Loadings") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

# negative loadings
ggraph(tg_ea_conn_cont_LV2_neg, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Negative Loadings") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

```

```{r}
# calculate mean within and between-network values for the contributions (sig only) - pos 
ea_conn_cont_LV2_pos_df <- data.frame(ea_conn_cont_LV2_pos)

# change duplicates to same value
ea_conn_cont_LV2_pos_dup <- data.frame(ea_conn_cont_LV2_pos[,2:4])
colnames(ea_conn_cont_LV2_pos_dup) <- c("y","x","r")
ea_conn_cont_LV2_pos_dup <- ea_conn_cont_LV2_pos_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV2_pos_dup <- ea_conn_cont_LV2_pos_dup[ea_conn_cont_LV2_pos_dup$r!=0,]

ea_conn_cont_LV2_pos_dup <- unite(ea_conn_cont_LV2_pos_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV2_pos_dup$rois) {
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$rois == i,"r"] <- ea_conn_cont_LV2_pos_dup[ea_conn_cont_LV2_pos_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values 
ea_conn_cont_LV2_pos_nets <- ea_conn_cont_LV2_pos_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),  # [r!=0] get mean of sig values only
            count=n())

ea_conn_cont_LV2_pos_nets$to <- as.factor(ea_conn_cont_LV2_pos_nets$to)
ea_conn_cont_LV2_pos_nets$from <- as.factor(ea_conn_cont_LV2_pos_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_pos_nets <- as_tbl_graph(ea_conn_cont_LV2_pos_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")  


# calculate mean within and between-network values for contributions (sig only) - neg 
ea_conn_cont_LV2_neg_df <- data.frame(ea_conn_cont_LV2_neg)

# change duplicates to same value
ea_conn_cont_LV2_neg_dup <- data.frame(ea_conn_cont_LV2_neg[,2:4])
colnames(ea_conn_cont_LV2_neg_dup) <- c("y","x","r")
ea_conn_cont_LV2_neg_dup <- ea_conn_cont_LV2_neg_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV2_neg_dup <- ea_conn_cont_LV2_neg_dup[ea_conn_cont_LV2_neg_dup$r!=0,]

ea_conn_cont_LV2_neg_dup <- unite(ea_conn_cont_LV2_neg_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV2_neg_dup$rois) {
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$rois == i,"r"] <- ea_conn_cont_LV2_neg_dup[ea_conn_cont_LV2_neg_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values
ea_conn_cont_LV2_neg_nets <- ea_conn_cont_LV2_neg_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),
            count=n())
ea_conn_cont_LV2_neg_nets$to <- as.factor(ea_conn_cont_LV2_neg_nets$to)
ea_conn_cont_LV2_neg_nets$from <- as.factor(ea_conn_cont_LV2_neg_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_neg_nets <- as_tbl_graph(ea_conn_cont_LV2_neg_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")

```

```{r fig.height=6.5, fig.width=8}
# mean nets positive loadings (contributions)
nets_pos_LV2 <- ggraph(tg_ea_conn_cont_LV2_pos_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #,alpha=.6
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.1)) +
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) + #, alpha=.6
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_pos_LV2 + geom_node_text(aes(label=name,colour=name), show.legend=F, nudge_x=nets_pos_LV2$data$x*.4, nudge_y=nets_pos_LV2$data$y*.2) 

data.frame(ea_conn_cont_LV2_pos_nets[order(ea_conn_cont_LV2_pos_nets$mean, decreasing = TRUE),])

# mean nets negative loadings
nets_neg_LV2 <- ggraph(tg_ea_conn_cont_LV2_neg_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #,alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.01)) +
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) +  #, alpha=.6
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_neg_LV2 + geom_node_text(aes(label=name,colour=name), show.legend=F, nudge_x=nets_neg_LV2$data$x*.4, nudge_y=nets_neg_LV2$data$y*.2) 

data.frame(ea_conn_cont_LV2_neg_nets[order(ea_conn_cont_LV2_neg_nets$mean, decreasing = TRUE),])

```

```{r, fig.height=5, fig.width=6}
# heatmap mean nets pos loadings (contribution)
ggplot(ea_conn_cont_LV2_pos_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "grey") +
  geom_tile(data = ea_conn_cont_LV2_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .25) +
  scale_fill_gradient(high = "#2166ac", low = "white", limit = c(0,.1), name="") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
        axis.text = element_text(size = 10, color=net_cols)) +
  ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

# neg loadings
ggplot(ea_conn_cont_LV2_neg_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "grey") +
  geom_tile(data = ea_conn_cont_LV2_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .25) +
  scale_fill_gradient(high = "#2166ac", low = "white", limit = c(0,.01), name="") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
        axis.text = element_text(size = 10, color=net_cols)) +
  ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

```




```{r warning=FALSE}
# PLSC by diagnostic group (results are the same as above, we will just examine them by group)
ea_plsc_gr <- tepPLS(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=spins_behav_combat$diagnostic_group, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_plsc_gr <- perm4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000) 

ea_plsc_gr$TExPosition.Data$t # to get variance explained
perm_ea_plsc_gr$pEigenvalues # to get LV p values

```

```{r warning=FALSE}
# plot scores 
LV1_gr <- cbind(ea_plsc_gr$TExPosition.Data$lx[,1],ea_plsc_gr$TExPosition.Data$ly[,1])
colnames(LV1_gr) <- c("Lx_conn 1", "Ly_beh 1")
rownames(LV1_gr) <- spins_behav_combat$diagnostic_group

# compute LV1 group means 
LV1_gr_mean <- getMeans(LV1_gr, spins_behav_combat$diagnostic_group)
rownames(LV1_gr_mean) <- c("case", "control")
colnames(LV1_gr_mean) <- c("Lx_conn 1", "Ly_beh 1")

# colours by group means
gr_colours <- dplyr::recode(rownames(LV1_gr),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV1_gr_mean),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV1_gr_mean_boot <- Boot4Mean(LV1_gr, spins_behav_combat$diagnostic_group)

# add colnames to array
colnames(ea_LV1_gr_mean_boot$BootCube) <- colnames(LV1_gr)

```

```{r warning=FALSE, fig.height=4.5, fig.width=6}
# plot LV1_gr
plot_LV1_gr <- createFactorMap(LV1_gr,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.3,
                         col.axes="black", 
                         col.background="white")

plot_LV1_gr_mean <- createFactorMap(LV1_gr_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              alpha.labels=0,
                              cex = 4.5,
                              pch = 17,
                              alpha.points = 0.8) 

plot_LV1_gr_meanCI <- MakeCIEllipses(ea_LV1_gr_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = as.matrix(gr_mean_colours),
                              names.of.factors = c("Lx_conn 1", "Ly_beh 1"))
                              
                         
cor.test(LV1_gr[rownames(LV1_gr)=="case","Lx_conn 1"],LV1_gr[rownames(LV1_gr)=="case","Ly_beh 1"]) # case r=.291, p<.0001
cor.test(LV1_gr[rownames(LV1_gr)=="control","Lx_conn 1"],LV1_gr[rownames(LV1_gr)=="control","Ly_beh 1"]) # control r=.159, p=.046
p.adjust(c(0.000000002899,0.01937), method = "fdr", n = 2)

plot1_LV1_gr <- plot_LV1_gr$zeMap_background + 
  plot_LV1_gr$zeMap_dots + 
  plot_LV1_gr_mean$zeMap_dots + 
  plot_LV1_gr_mean$zeMap_text +
  plot_LV1_gr_meanCI +
  coord_cartesian(xlim=c(-4.5, 5), ylim=c(-0.5, 0.3)) + 
  ggtitle("EA Dimension 1: Latent Variable Scores by Diagnostic Group") +
         labs(y = "Behavior Scores", x = "Connectivity Scores")

print(plot1_LV1_gr)

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for conn scores
LV1_gr_demo <- data.frame(cbind(LV1_gr,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.1 ~ diagnostic_group, data=LV1_gr_demo, paired=F)

# confirmed this is identical in model without design by group 

# plot scores by group
ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Lx_conn.1, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Connectivity Scores", x="SSD                     Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("#00BFC4","#8494FF")) + # maybe change colours #00AFBB
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Lx_conn.1, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Connectivity Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())


```

```{r fig.height=4, fig.width=5.5}
# t-tests by diagnostic group for beh scores
t.test(Ly_beh.1 ~ diagnostic_group, data=LV1_gr_demo, paired=F)

p.adjust(c(.00000,.00000), method = "fdr", n = 2)

# plot scores by group
ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Ly_beh.1, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Behavior Scores", x="SSD                       Control") +
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Ly_beh.1, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Behavior Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```


```{r warning=FALSE}
# plot LV2 scores 
LV2_gr <- cbind(ea_plsc_gr$TExPosition.Data$lx[,2],ea_plsc_gr$TExPosition.Data$ly[,2])
colnames(LV2_gr) <- c("Lx_conn 2", "Ly_beh 2")
rownames(LV2_gr) <- spins_behav_combat$diagnostic_group

# compute LV2 group means 
LV2_gr_mean <- getMeans(LV2_gr, spins_behav_combat$diagnostic_group)
rownames(LV2_gr_mean) <- c("case", "control")
colnames(LV2_gr_mean) <- c("Lx_conn 2", "Ly_beh 2")

# colours by group means
gr_colours <- dplyr::recode(rownames(LV2_gr),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV2_gr_mean),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV2_gr_mean_boot <- Boot4Mean(LV2_gr, spins_behav_combat$diagnostic_group)

# add colnames to array
colnames(ea_LV2_gr_mean_boot$BootCube) <- colnames(LV2_gr)

```


```{r warning=FALSE, fig.height=4.5, fig.width=6}
# plot LV2_gr
plot_LV2_gr <- createFactorMap(LV2_gr,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.3,
                         col.axes="black", 
                         col.background="white")

plot_LV2_gr_mean <- createFactorMap(LV2_gr_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              alpha.labels=0,
                              cex = 4.5,
                              pch = 17,
                              alpha.points = 0.8)

plot_LV2_gr_meanCI <- MakeCIEllipses(ea_LV2_gr_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = gr_mean_colours,
                              names.of.factors = c("Lx_conn 2", "Ly_beh 2"))
                              
                         
cor.test(LV2_gr[rownames(LV2_gr)=="case","Lx_conn 2"],LV2_gr[rownames(LV2_gr)=="case","Ly_beh 2"]) # case r=.377, p<.0001
cor.test(LV2_gr[rownames(LV2_gr)=="control","Lx_conn 2"],LV2_gr[rownames(LV2_gr)=="control","Ly_beh 2"]) # control r=.464, p<.0001
p.adjust(c(.000035,0.00041), method = "fdr", n = 2)
  
plot1_LV2_gr <- plot_LV2_gr$zeMap_background + 
  plot_LV2_gr$zeMap_dots + 
  plot_LV2_gr_mean$zeMap_dots + 
  plot_LV2_gr_mean$zeMap_text +
  plot_LV2_gr_meanCI +
  coord_cartesian(xlim=c(-3, 5.5), ylim=c(-0.2, 0.25)) +
  ggtitle("EA Dimension 2: Latent Variable Scores by Diagnostic Group") +
         labs(y = "Behavior", x = "Connectivity")

print(plot1_LV2_gr)

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for conn scores
LV2_gr_demo <- data.frame(cbind(LV2_gr,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.2 ~ diagnostic_group, data=LV2_gr_demo, paired=F)

# plot scores by group
ggplot(LV2_gr_demo, aes( x = diagnostic_group, y = Lx_conn.2, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Connectivity Scores", x="SSD                          Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV2_gr_demo, aes( x = diagnostic_group, y = Lx_conn.2, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Connectivity Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for beh scores
t.test(Ly_beh.2 ~ diagnostic_group, data=LV2_gr_demo, paired=F)

p.adjust(c(.198,.146), method = "fdr", n = 2)

# plot scores by group
ggplot(LV2_gr_demo, aes( x= diagnostic_group, y = Ly_beh.2, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Behavior Scores", x="SSD                            Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV2_gr_demo, aes( x= diagnostic_group, y = Ly_beh.2, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Behavior Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```


```{r}
# control analyses - check for associations between scores and confounds
# add scores to demo data
LV_demo <- data.frame(cbind(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1],ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2],spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

colnames(LV_demo)[1:4] <- c("Lx_conn.1","Ly_beh.1","Lx_conn.2","Ly_beh.2")

# add education info (highest grade) - nm this as clearly related to cognition
#LV_demo <- merge(LV_demo,spins_behav[,c("record_id","demo_highest_grade_self")],by="record_id")

# add ea mean FD data
spins_fd <- read.csv(file="/projects/loliver/QC/spins_mean_fd_per_run.csv",stringsAsFactors=F,header=T)
LV_demo <- merge(LV_demo,spins_fd[,c("record_id","fd_mean.task.emp_bold")],by="record_id")

# correlations between scores and age and mean FD # NS p=1
rcorr(as.matrix(LV_demo[,c(2:5,8:9)])) 

# t-tests for sex # all NS p=1
t.test(Lx_conn.1 ~ demo_sex, data=LV_demo, paired=F)
t.test(Ly_beh.1 ~ demo_sex, data=LV_demo, paired=F)

t.test(Lx_conn.2 ~ demo_sex, data=LV_demo, paired=F)
t.test(Ly_beh.2 ~ demo_sex, data=LV_demo, paired=F)

```

```{r}
# visualize associations

# Dimension 1
ggplot(LV_demo, aes(x=Lx_conn.1, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.1, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo, aes(x=Lx_conn.1, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.1, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

# Dimension 2
ggplot(LV_demo, aes(x=Lx_conn.2, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.2, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 
  
ggplot(LV_demo, aes(x=Lx_conn.2, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.2, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 
  
```

```{r}
# examine correlations between scores from orig model and this regressed model

# add orig scores to demo data
ea_orig_scores <- read.csv(file="/projects/loliver/SPINS_PLS_Conn/data/processed/spins_ea_plsc_scores.csv",stringsAsFactors=F,header=T)
LV_demo <- merge(LV_demo,ea_orig_scores[,c("record_id","Lx_conn.1","Ly_beh.1","Lx_conn.2","Ly_beh.2")],by="record_id")

# correlations between orig and new scores 
rcorr(as.matrix(LV_demo[,c(2:5,10:13)]))

```


```{r}
# examine relationships between scores and clinical measures and functioning 
# add scores to demo data
LV_demo_clin <- merge(LV_demo, spins_behav_conn[spins_behav_conn$record_id %in% LV_demo$record_id, c("record_id","bprs_factor_total","sans_total_sc","qls_total","bsfs_total")], by="record_id")

# add CPZE data 
spins_cpze <- read.csv(file="/projects/loliver/SPINS/data/final_cpzeqv.csv",stringsAsFactors=F,header=T)
LV_demo_clin <- merge(LV_demo_clin, spins_cpze[spins_cpze$record_id %in% LV_demo_clin$record_id,c("record_id","cpz_eq_total")], by="record_id",all=TRUE)

# look for NAs in SSDs only # N=19 missing CPZEs; N=1 missing QLS total
LV_demo_clin_SSD <- LV_demo_clin[LV_demo_clin$diagnostic_group=="case",]
LV_demo_clin_SSD[!complete.cases(LV_demo_clin_SSD),] 

# identify any patients missing from spins_cpze # N=19 - look into this
LV_demo_clin[!(LV_demo_clin$record_id %in% spins_cpze$record_id) & LV_demo_clin$diagnostic_group=="case",]

# correlations between dim scores and BPRS total, SANS total, QLS total, BSFS total, and CPZE
rcorr(as.matrix(LV_demo_clin[,c(2:5,10:14)]))

p.adjust(c(.0044,.0000), method = "fdr", n = 2) # dim 1 cpze only for now
p.adjust(c(.735,.884), method = "fdr", n = 2) # dim 2 cpze only for now

```

```{r}
# visualize associations

# Dimension 1
ggplot(LV_demo_clin, aes(x=Lx_conn.1, y=cpz_eq_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  #labs(x ="Control A Stimulation", 
  #     y = "3-Back Accuracy (d') Post") +
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.1, y=cpz_eq_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Lx_conn.1, y=bsfs_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.1, y=bsfs_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.1, y=sans_total_sc)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Lx_conn.1, y=sans_total_sc)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

# Dimension 2
ggplot(LV_demo_clin, aes(x=Lx_conn.2, y=cpz_eq_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.2, y=cpz_eq_total)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Lx_conn.2, y=bsfs_total, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.2, y=bsfs_total, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Lx_conn.2, y=sans_total_sc)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo_clin, aes(x=Ly_beh.2, y=sans_total_sc)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

```



```{r warning=FALSE}
# PLSC by sex # again, same as overall results
ea_plsc_sex <- tepPLS(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=spins_behav_combat$demo_sex, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_plsc_sex <- perm4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000) 

ea_plsc_sex$TExPosition.Data$t # to get variance explained
perm_ea_plsc_sex$pEigenvalues # to get LV p values

```

```{r warning=FALSE}
# plot scores 
LV1_sex <- cbind(ea_plsc_sex$TExPosition.Data$lx[,1],ea_plsc_sex$TExPosition.Data$ly[,1])
colnames(LV1_sex) <- c("Lx_conn 1", "Ly_beh 1")
rownames(LV1_sex) <- spins_behav_combat$demo_sex

# compute LV1 group means 
LV1_sex_mean <- getMeans(LV1_sex, spins_behav_combat$demo_sex)

# colours by group means
gr_colours <- dplyr::recode(rownames(LV1_sex),
                       'female' = '#F8766D',
                       'male' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV1_sex_mean),
                       'female' = '#F8766D',
                       'male' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV1_sex_mean_boot <- Boot4Mean(LV1_sex, spins_behav_combat$demo_sex)

# add colnames to iterations (they are in an array, so not sure how to do this atm)? 
#for (i in names(ea_LV1_sex_mean_boot$BootCube)) {
#  colnames(ea_LV1_sex_mean_boot$BootCube[[i]]) <- colnames(LV1_sex)
#}

#apply(ea_LV1_sex_mean_boot$BootCube, 3, setNames, nm=colnames(LV1_sex))

```

```{r warning=FALSE}
# plot LV1_sex
plot_LV1_sex <- createFactorMap(LV1_sex,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.2)

plot_LV1_sex_mean <- createFactorMap(LV1_sex_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              cex = 4,
                              pch = 17,
                              alpha.points = 0.8)

plot_LV1_sex_meanCI <- MakeCIEllipses(ea_LV1_sex_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = gr_mean_colours)
                              
                         
cor.test(LV1_sex[rownames(LV1_sex)=="female","Lx_conn 1"],LV1_sex[rownames(LV1_sex)=="female","Ly_beh 1"]) # female r=.457, p<.0001
cor.test(LV1_sex[rownames(LV1_sex)=="male","Lx_conn 1"],LV1_sex[rownames(LV1_sex)=="male","Ly_beh 1"]) # male r=.413, p<.0001

plot1_LV1_sex <- plot_LV1_sex$zeMap_background + 
  plot_LV1_sex$zeMap_dots + 
  plot_LV1_sex_mean$zeMap_dots + 
  plot_LV1_sex_mean$zeMap_text +
  #plot_LV1_sex_meanCI +
  coord_cartesian() +
  ggtitle("Latent Variable 1: Factor Scores by Sex at Birth") +
         labs(y = "LV 1 Y Behaviour Scores", x = "LV 1 X Connectivity Scores")

print(plot1_LV1_sex)

```

```{r fig.height=4, fig.width=8}
# t-tests by sex for conn scores
LV1_sex_demo <- data.frame(cbind(LV1_sex,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.1 ~ demo_sex, data=LV1_sex_demo, paired=F) # NS

# plot scores by group
ggplot(LV1_sex_demo, aes(x= demo_sex, y = Lx_conn.1, col = demo_sex)) +
  geom_boxplot() + labs(y = "LV1 Connectivity Scores", x="female                     male") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV1_sex_demo, aes(x= demo_sex, y = Lx_conn.1, fill = demo_sex)) + 
     geom_boxplot(outlier.shape = NA, alpha = 0.0001) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center') +
     geom_hline(yintercept = 0) +
     labs( x=NULL,      
           y = bquote('LV1 Connectivity Scores'),
           fill = "Sex at Birth") +
     scale_fill_manual(values = c("blue","red")) +
#    facet_wrap(~Region) + could use for densities
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

```

```{r fig.height=4, fig.width=8}
# t-tests by sex for beh scores
t.test(Ly_beh.1 ~ demo_sex, data=LV1_sex_demo, paired=F)

# plot scores by group
ggplot(LV1_sex_demo, aes(x= demo_sex, y = Ly_beh.1, col = demo_sex)) +
  geom_boxplot() + labs(y = "LV1 Behaviour Scores", x="female                       male") +
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

```

```{r warning=FALSE}
# plot LV2 scores 
LV2_sex <- cbind(ea_plsc_sex$TExPosition.Data$lx[,2],ea_plsc_sex$TExPosition.Data$ly[,2])
colnames(LV2_sex) <- c("Lx_conn 2", "Ly_beh 2")
rownames(LV2_sex) <- spins_behav_combat$demo_sex

# compute LV2 group means 
LV2_sex_mean <- getMeans(LV2_sex, spins_behav_combat$demo_sex)

# colours by group means
gr_colours <- dplyr::recode(rownames(LV2_sex),
                       'female' = '#F8766D',
                       'male' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV2_sex_mean),
                       'female' = '#F8766D',
                       'male' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV2_sex_mean_boot <- Boot4Mean(LV2_sex, spins_behav_combat$demo_sex)

```

```{r warning=FALSE}
# plot LV2_sex
plot_LV2_sex <- createFactorMap(LV2_sex,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.2)

plot_LV2_sex_mean <- createFactorMap(LV2_sex_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              cex = 4,
                              pch = 17,
                              alpha.points = 0.8)

plot_LV2_sex_meanCI <- MakeCIEllipses(ea_LV2_sex_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = gr_mean_colours)
                              
                         
cor.test(LV2_sex[rownames(LV2_sex)=="female","Lx_conn 2"],LV2_sex[rownames(LV2_sex)=="female","Ly_beh 2"]) # female r=.318, p=.00016
cor.test(LV2_sex[rownames(LV2_sex)=="male","Lx_conn 2"],LV2_sex[rownames(LV2_sex)=="male","Ly_beh 2"]) # male r=.270, p<.0001
  
plot1_LV2_sex <- plot_LV2_sex$zeMap_background + 
  plot_LV2_sex$zeMap_dots + 
  plot_LV2_sex_mean$zeMap_dots + 
  plot_LV2_sex_mean$zeMap_text +
  #plot_LV2_sex_meanCI +
  coord_cartesian() +
  ggtitle("Latent 2: Observations Factor Scores by Sex at Birth") +
         labs(y = "Latent 2 - y ", x = "Latent 2 - x")

print(plot1_LV2_sex)

```

```{r fig.height=4, fig.width=8}
# t-tests by diagnostic group for conn scores
LV2_sex_demo <- data.frame(cbind(LV2_sex,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.2 ~ demo_sex, data=LV2_sex_demo, paired=F)

# plot scores by group
ggplot(LV2_sex_demo, aes( x= demo_sex, y = Lx_conn.2, col = demo_sex)) +
  geom_boxplot() + labs(y = "LV2 Connectivity Scores", x="female                          male") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

```

```{r fig.height=4, fig.width=8}
# t-tests by diagnostic group for beh scores
t.test(Ly_beh.2 ~ demo_sex, data=LV2_sex_demo, paired=F)

# plot scores by group
ggplot(LV2_sex_demo, aes( x= demo_sex, y = Ly_beh.2, col = demo_sex)) +
  geom_boxplot() + labs(y = "LV2 Behaviour Scores", x="female                            male") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

```












```{r warning=FALSE}
# salience plots and bootstrapping for contributor significance

# contributions are absolute values, so need to get signs based on factor scores
Cx_conn_gr <- ea_plsc_gr$TExPosition.Data$ci * sign(ea_plsc_gr$TExPosition.Data$fi)
Cy_beh_gr <- ea_plsc_gr$TExPosition.Data$cj * sign(ea_plsc_gr$TExPosition.Data$fj)

# bootstrapped model 
set.seed(999)
ea_plsc_boot_gr <- Boot4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000,
  critical.value = 2, nf2keep = 3, alphaLevel = 0.05) 

```

```{r fig.height=6, fig.width=6}
# salience plots by group - UPDATE
# sig conn for LV1
names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))

#LV1_Conn <- PrettyBarPlot2(bootratio = round(100000*Cx_conn[,1]), 
#            threshold = 100/nrow(Cx_conn),
#            signifOnly = TRUE,
#            plotnames = TRUE,
#            main = "Conn Factor Loadings LV1",
#            ylab = "Variable Factor Loadings")

# sig conn for LV2
names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)) 

#LV2_Conn <- PrettyBarPlot2(bootratio = round(100*Cx_conn[,2]), 
#            plotnames = TRUE,
#            signifOnly = TRUE,
#            main = "Conn Factor Loadings LV2",
#            ylab = "Variable Factor Loadings")


# sig beh for LV1
names(which(ea_plsc_boot$bootRatiosSignificant.j[,1] == TRUE))

PrettyBarPlot2(bootratio = round(100*Cy_beh[,1]),
            threshold = 1.5,
            plotnames = TRUE,
            font.shrink = 0,
            font.size = 7,
            main = "Beh Factor Loadings LV1",
            ylab = "Variable Factor Loadings") +
            theme(axis.text.y = element_text(size=16))

# sig beh for LV2
names(which(ea_plsc_boot$bootRatiosSignificant.j[,2] == TRUE))

PrettyBarPlot2(bootratio = round(100*Cy_beh[,2]),
            threshold = 9,
            plotnames = TRUE,
            font.shrink = 0,
            font.size = 7,
            main = "Beh Factor Loadings LV2",
            ylab = "Variable Factor Loadings") +
            theme(axis.text.y = element_text(size=16))


```


```{r}
# PLSC with only soc cog beh variables

# create separate X and Y matrices 
sc_conn <- conn # x var
sc_beh <- beh[,1:9] # y var


# yeo johnson family transform beh variables - decide whether we want to do this (and do above as well if so) - skip for now
get_pT_yj <- function(x) {
  pT <- x^powerTransform(x,family="yjPower")$lambda
  return(pT)
}

sc_beh <- apply(sc_beh,2,get_pT_yj)


# examine covariance - maybe after so we can focus on most relevant variables

# run pls including centering and scaling, per behavioural PLS in MATLAB - centered and normalized with sum of squares of each column equal to 1
ea_sc_plsc <- tepPLS(sc_conn, sc_beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=NULL, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_sc_plsc <- perm4PLSC(sc_conn, sc_beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 500) 

#plot scree
PlotScree(ev = ea_sc_plsc$TExPosition.Data$eigs, p.ev = perm_ea_sc_plsc$pEigenvalues, plotKaiser = TRUE, col.ns = "black",
          col.sig = "red")

# plot scores 
sc_LV1 <- cbind(ea_sc_plsc$TExPosition.Data$lx[,1],ea_sc_plsc$TExPosition.Data$ly[,1])
colnames(sc_LV1) <- c("Lx_conn 1", "Ly_beh 1")
plot_sc_LV1 <- createFactorMap(sc_LV1) 

cor(ea_sc_plsc$TExPosition.Data$lx[,1],ea_sc_plsc$TExPosition.Data$ly[,1])
plot_sc_LV1$zeMap_background + plot_sc_LV1$zeMap_dots + coord_cartesian() 


sc_LV2 <- cbind(ea_sc_plsc$TExPosition.Data$lx[,2],ea_sc_plsc$TExPosition.Data$ly[,2])
colnames(sc_LV2) <- c("Lx_conn 2", "Ly_beh 2")
plot_sc_LV2 <- createFactorMap(sc_LV2, constraints = NULL)

cor(ea_sc_plsc$TExPosition.Data$lx[,2],ea_sc_plsc$TExPosition.Data$ly[,2])
plot_sc_LV2$zeMap_background + plot_sc_LV2$zeMap_dots + coord_cartesian() 


# salience plots and bootstrapping for contributor significance
# contributions/saliences (loadings) are absolute values, so need to get signs based on factor scores
Cx_sc_conn <- ea_sc_plsc$TExPosition.Data$ci * sign(ea_sc_plsc$TExPosition.Data$fi)
Cy_sc_beh <- ea_sc_plsc$TExPosition.Data$cj * sign(ea_sc_plsc$TExPosition.Data$fj)

# bootstrapped model
ea_sc_plsc_boot <- Boot4PLSC(sc_conn, sc_beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000,
  critical.value = 2, nf2keep = 3, alphaLevel = 0.05)

```

```{r}
# salience plots
# sig conn for LV1
names(which(ea_sc_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))

#LV1_sc_Conn <- PrettyBarPlot2(bootratio = round(100*Cx_sc_conn[,1]), 
#            threshold = 100/nrow(Cx_sc_conn),
#            #signifOnly = TRUE,
#            plotnames = TRUE,
#            main = "Conn Factor Loadings LV1",
#            ylab = "Variable Factor Loadings")

# sig conn for LV2
names(which(ea_sc_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))

#LV2_sc_Conn <- PrettyBarPlot2(bootratio = round(100*Cx_sc_conn[,2]), 
#            plotnames = TRUE,
#            signifOnly = TRUE,
#            main = "Conn Factor Loadings LV2",
#            ylab = "Variable Factor Loadings")


# sig beh for LV1
names(which(ea_sc_plsc_boot$bootRatiosSignificant.j[,1] == TRUE))

PrettyBarPlot2(bootratio = round(100*Cy_sc_beh[,1]), 
            plotnames = TRUE,
            main = "Beh Factor Loadings LV1",
            ylab = "Variable Factor Loadings")

# sig beh for LV2
names(which(ea_sc_plsc_boot$bootRatiosSignificant.j[,2] == TRUE))

PrettyBarPlot2(bootratio = round(100*Cy_sc_beh[,2]), 
            plotnames = TRUE,
            main = "Beh Factor Loadings LV2",
            ylab = "Variable Factor Loadings")

```


```{r}

```


```{r}
# visualize time series for EA in Glasser ROIs - can try later

for (i in names(EA_resid_ts)) {
  EA_resid_ts_melt[[i]]$TR <- 1:819 
  EA_resid_ts_melt[[i]] <- melt(EA_resid_ts_melt[[i]],id="TR")
}

for (i in names(resid_times_rois_melt)) {
  ggplot(data.frame(resid_times_rois_melt[[i]]), aes(x = Sub.brick, y = value, group = 1)) + geom_line() + facet_wrap("variable") + ggtitle(i)
}


```

```{r}
# visualize correlation matrix for each participant
for (i in names(cor_EA_diag[1:50])) {
  corrplot(cor_EA[[i]], method="color",type="lower",tl.cex=.6,tl.col="black",title=i)
}

corrplot(cor_EA[["SPN01_CMH_0159"]], method="color",type="lower",tl.cex=.6,tl.col="black")
corrplot(cor_EA[["SPN01_ZHP_0123"]], method="color",type="lower",tl.cex=.6,tl.col="black")
```


```{r}

```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
