---
title: "02_EA_PLSC_subcor_combat_regress_thresholded"
output: html_notebook
editor_options:
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(splitstackshape)
library(plyr)
library(dplyr)
library(tidyr)
library(corrr)
library(psych)
library(Hmisc)
library(TExPosition)
library(data4PCCAR)
library(PTCA4CATA)
library(tableone)
library(corrplot)
library(mice)
library(ggplot2)
library(stringr)
library(colorspace)

```

```{r}
# set working dir
setwd("/scratch/loliver/SPINS_PLS_Conn")

# find EA residual time series files # pattern glob2rx("sub*_EA_2mm_noGSR_glasser_tian_meants.csv") 
files_EA_resid_ts <- list.files(path= ".", recursive=T, full.names=F, pattern="^sub.*_EA_2mm_noGSR_glasser_tian_meants\\.csv$") 

# confirm csvs aren't empty
files_EA_resid_ts[file.size(files_EA_resid_ts) == 0]

# create list of IDs
ptlist <- paste("SPN01", substring(files_EA_resid_ts,5,7), substring(files_EA_resid_ts,8,11), sep = "_")

# read in time series files
resid_ts <- lapply(files_EA_resid_ts, read.csv, header=F)

# transpose dfs
resid_ts <- lapply(resid_ts, t)

# Name dfs with participant IDs # N=438
names(resid_ts) <- ptlist

```

```{r}
# read in new inclusion list based on EA task, motion, and imaging (fmriprep and ciftify) QC (see /projects/loliver/QC/SPINS_EA_Exclusion.R)
# also checked old participants.tsv file to make sure nothing being missed
include_list <- read.csv(file="/projects/loliver/QC/SPINS_EA_QC_fMRI_inclusion_list.csv", header=F)

resid_ts <- resid_ts[names(resid_ts) %in% include_list$V1] # N=359

```

```{r}
# find circles onsets for each participant - these were increased by 1 s due to the slice timing change
setwd("/scratch/loliver/SPINS_PLS_Conn")
files_circles <- list.files(path= ".", recursive=T, full.names=F, pattern="^.*_circles\\.1D$")

# create list of IDs
circ_ptlist <- paste("SPN01", substring(files_circles,5,7), substring(files_circles,8,11), sep = "_")

# read in circles files
circles <- lapply(files_circles, read.csv, header=F, sep=" ", colClasses=c(NA, NA, "NULL"))
names(circles) <- circ_ptlist

# get circles onset times into same row, adding 546 s per run (273 TRs/run), dividing by 2 as TRs are 2s, and adding 1 s due to slice timing correction being from middle of TR in fmriprep
circles_times <- list()

for (i in names(circles)) {
  circles_times[[i]] <- round(((cbind(circles[[i]][1,],(circles[[i]][2,])+546,(circles[[i]][3,])+1092))/2)+1)
}

# remove circles from time series data (circles runs are 20 TRs or 40 s - this way we are removing 20 TRs - the onset + 19)
ea_resid_ts <- list()

for (i in names(resid_ts)) {
  ea_resid_ts[[i]] <- resid_ts[[i]][-c(circles_times[[i]][1,1]:(circles_times[[i]][1,1]+19),circles_times[[i]][1,2]:(circles_times[[i]][1,2]+19),
                         circles_times[[i]][1,3]:(circles_times[[i]][1,3]+19),circles_times[[i]][1,4]:(circles_times[[i]][1,4]+19),
                         circles_times[[i]][1,5]:(circles_times[[i]][1,5]+19),circles_times[[i]][1,6]:(circles_times[[i]][1,6]+19)),]
}


# check dims
#lapply(ea_resid_ts, dim)

# check for NAs
#for (i in names(ea_resid_ts)) {
#  print (i)
#  print(which(is.na(ea_resid_ts[[i]])))
#}

```

```{r}
# read in behavioural data for those with cognitive data (IDs have been changed for those with repeated scans, scanner variable updated, and EA scores added) - N=455
spins_behav <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_data_cog_08-12-2024.csv", header = T, stringsAsFactors = F)

# keep only participants we have EA connectivity data for - N=356
spins_behav_conn <- spins_behav[spins_behav$record_id %in% names(ea_resid_ts),]

# ZHP_0110 and ZHP_0172 did not complete multiple soc cog tasks - exclude these participants - N=354 
spins_behav_conn <- spins_behav_conn[spins_behav_conn$record_id!="SPN01_ZHP_0110" & spins_behav_conn$record_id!="SPN01_ZHP_0172",]

# run if want to remove the additional 2 participants in the EA sample who don't have RS data - N=352
spins_behav_conn <- spins_behav_conn[spins_behav_conn$record_id!="SPN01_MRC_0046" & spins_behav_conn$record_id!="SPN01_ZHH_0034",]

# keep EA data from same sample 
ea_resid_ts <- ea_resid_ts[names(ea_resid_ts) %in% spins_behav_conn$record_id]

```

```{r}
# read in Tian and Glasser ROI labels (392)
rois <- read.csv(file = "/projects/loliver/SPINS_PLS_Conn/data/parcellations/Glasser_Tian_roi_info.csv", header=T)

# read in Alcala-Lopez et al. (2018) soc cog Glasser ROIs
# sc_rois <- read.csv(file = "/projects/loliver/SPINS_PLS_Conn/data/parcellations/Glasser_Alcala-Lopez_scog_rois.csv", header=F)

# add labels to df columns # dashes in roi names become dots here
for (i in names(ea_resid_ts)) {
  colnames(ea_resid_ts[[i]]) <- as.vector(rois$atlas_roi)
  ea_resid_ts[[i]] <- data.frame(ea_resid_ts[[i]])
}

# Generate correlation matrices for each participant 
ea_cor <- lapply(ea_resid_ts, correlate)

# set upper triangle to NA
ea_cor <- lapply(ea_cor, shave)

# create dfs with corrs for each participant
ea_cor_str <- lapply(ea_cor, stretch, na.rm=F)
ea_cor_stru <- lapply(ea_cor_str, unite, col="rois", 1:2, sep="-", remove=T)
ea_cor_df <- lapply(ea_cor_stru, data.frame)

# change col 1 to row names
cor_names <- as.vector(ea_cor_df[[1]][,1])

for (i in names(ea_cor_df)) {
  ea_cor_df[[i]] <- data.frame(ea_cor_df[[i]][,2])
  ea_cor_df[[i]] <- t(ea_cor_df[[i]])
  colnames(ea_cor_df[[i]]) <- cor_names
}

# bind rows across df list to generate tibble with all corrs for each participant
ea_corrs <- do.call("rbind",ea_cor_df)
rownames(ea_corrs) <- names(ea_cor_df)

# remove columns with only NAs
ea_corrs <- ea_corrs[,colSums(is.na(ea_corrs)) != nrow(ea_corrs)]

# fisher z transform corrs
ea_corrs_z  <- fisherz(ea_corrs)

```

```{r}
# read in variables for combat with imputed data for missing values using mice 
spins_behav_combat <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_ea_combat_08-16-2024.csv", header = T, stringsAsFactors = F)

```

```{r}
# read in ComBat connectivity data 
ea_combat_data <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_ea_combat_data_01-10-2025.csv", header = T, row.names = 1)

```

```{r}
# regress age, sex, mean FD out of conn and behav metrics before running PLS 

# read in rs mean FD data
spins_fd <- read.csv(file="/projects/loliver/QC/spins_mean_fd_per_run.csv",stringsAsFactors=F,header=T)

# behav data
spins_behav_combat_reg <- merge(spins_behav_combat,spins_fd[,c("record_id","fd_mean.task.emp_bold")],by="record_id")

spins_behav_combat_reg[,6:20] <- apply(spins_behav_combat_reg[,6:20], 2, function(x) lm(x ~ spins_behav_combat_reg$demo_age_study_entry + spins_behav_combat_reg$demo_sex + spins_behav_combat_reg$fd_mean.task.emp_bold)$residual)

spins_behav_combat <- spins_behav_combat_reg

# conn data
ea_combat_data_reg <- data.frame(ea_combat_data)
ea_combat_data_reg$demo_age_study_entry <- spins_behav_combat$demo_age_study_entry
ea_combat_data_reg$demo_sex <- spins_behav_combat$demo_sex
ea_combat_data_reg$fd_mean.task.emp_bold <- spins_behav_combat_reg$fd_mean.task.emp_bold

ea_combat_data_reg[,1:76636] <- apply(ea_combat_data_reg[,1:76636], 2, function(x) lm(x ~ ea_combat_data_reg$demo_age_study_entry +  ea_combat_data_reg$demo_sex + ea_combat_data_reg$fd_mean.task.emp_bold)$residual)

ea_combat_data_reg <- ea_combat_data_reg[,1:76636]

ea_combat_data <- ea_combat_data_reg

```

```{r warning=FALSE}
# PLSC (Derek Beaton's pkg; symmetric analysis as per McIntosh et al., 1996)

# identify top 10% most variable connections as measured by median absolute deviation to reduce number of connectivity inputs (more robust against outliers than standard deviation as per Xia et al., 2018)
mad_conn <- apply(ea_combat_data, 2, mad)

# 76636*.1 = 7664
top_10 <- names(sort(mad_conn, decreasing=TRUE)[1:7664])

# create separate X and Y matrices 
conn_top_10 <- colnames(ea_combat_data[,colnames(ea_combat_data) %in% top_10])
conn <- as.matrix(ea_combat_data[,colnames(ea_combat_data) %in% top_10]) # x var

beh <- as.matrix(spins_behav_combat[,c("scog_rmet_total","scog_er40_total","scog_mean_ea","scog_tasit1_total","scog_tasit2_sinc",
          "scog_tasit2_simpsar","scog_tasit2_parsar","scog_tasit3_lie","scog_tasit3_sar",
          "np_domain_tscore_process_speed","np_domain_tscore_att_vigilance","np_domain_tscore_work_mem",
          "np_domain_tscore_verbal_learning","np_domain_tscore_visual_learning","np_domain_tscore_reasoning_ps")]) # y var
rownames(beh) <- spins_behav_combat$record_id
colnames(beh) <- c("RMET","ER40","EA","TASIT1","T2_sinc","T2_simsar","T2_parsar","T3_lie","T3_sar","Proc_Speed","Att_Vig","Work_Mem",
"Verb_Learn","Vis_Learn","Reason_PS") 

conn <- conn[rownames(conn) %in% rownames(beh),]

# generate table one - with imputed values
char_table <- spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry","scog_rmet_total","scog_er40_total",
          "scog_mean_ea","scog_tasit1_total","scog_tasit2_sinc","scog_tasit2_simpsar","scog_tasit2_parsar","scog_tasit3_lie","scog_tasit3_sar",
          "np_domain_tscore_process_speed","np_domain_tscore_att_vigilance","np_domain_tscore_work_mem",
          "np_domain_tscore_verbal_learning","np_domain_tscore_visual_learning","np_domain_tscore_reasoning_ps")]
#char_table <- na.omit(char_table)
colnames(char_table) <- c("record_id","Diagnostic_Group","Sex_at_birth","Age","RMET","ER40","EA","TASIT1","T2_sinc","T2_simsar","T2_parsar",
                          "T3_lie","T3_sar","Proc_Speed","Att_Vig","Work_Mem","Verb_Learn","Vis_Learn","Reason_PS") 

table_one <- CreateTableOne(strata="Diagnostic_Group",data=char_table[,2:19])
table <- print(table_one)

#write.csv(table,file="/projects/loliver/SPINS_PLS_Conn/data/processed/tableone_ea_rs_imp_09-19-2023.csv")

char_table_clin <- merge(char_table,spins_behav_conn[,c("record_id","wtar_std_score","bprs_factor_total","sans_total_sc","qls_total","bsfs_total")],by="record_id")

table_one_clin <- CreateTableOne(strata="Diagnostic_Group",data=char_table_clin[,2:24])
table_clin <- print(table_one_clin)

#write.csv(table_clin,file="/projects/loliver/SPINS_PLS_Conn/data/processed/tableone_ea_rs_imp_clin_09-19-2023.csv")

```

```{r warning=FALSE, fig.height=6, fig.width=6}
# run pls - include scaling as these variables have not been z-scored
# per behavioural PLS in MATLAB (centered and normalized with sum of squares of each column equal to 1)
ea_plsc <- tepPLS(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=NULL, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_plsc <- perm4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000) 

# plot scree
PlotScree(ev = ea_plsc$TExPosition.Data$eigs, p.ev = perm_ea_plsc$pEigenvalues, plotKaiser = TRUE, col.ns = "black",
          col.sig = "red")

ea_plsc$TExPosition.Data$t # to get variance explained
perm_ea_plsc$pOmnibus # check omnibus test
perm_ea_plsc$pEigenvalues # to get LV p values

```

```{r}
# run permutation for second eigenvalue
# Ju-Chi's code to regress out effects from first latent component/dimension to then check for second

lx1 <- as.matrix(ea_plsc$TExPosition.Data$lx[,1])
ly1 <- ea_plsc$TExPosition.Data$ly[,1]

X.proc <- expo.scale(conn, center = TRUE, scale = "SS1") # what you originally do for center1 and scale1 (TRUE and "SS1" are the default setting of tepPLS)
Y.proc <- expo.scale(beh, center = TRUE, scale = "SS1") # what you originally do for center2 and scale2 (TRUE and "SS1" are the default setting of tepPLS)

# regress Lx and Ly from X and Y
Xhat <- lm(X.proc~lx1)$residuals
Yhat <- lm(Y.proc~ly1)$residuals

set.seed(999)
pls.inf2 <- data4PCCAR::perm4PLSC(Xhat, Yhat, 
                                 center1 = FALSE, scale1 = FALSE, 
                                 center2 = FALSE, scale2 = FALSE, 
                                 nIter = 1000)

# check if the model is significant overall # changed 'f's to 'p's
# if this is not significant, your analysis is really unidimensional
pls.inf2$pOmnibus

# check if the first eigenvalue is significant - it is (p=.005)
pls.inf2$pEigenvalues

```

```{r warning=FALSE, fig.height=4, fig.width=5}
# plot scores (latent variables, or latent variable scores)
LV1 <- cbind(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1])
colnames(LV1) <- c("Connectivity Latent Variable Scores", "Behavior Latent Variable Scores")
plot_LV1 <- createFactorMap(LV1, col.axes="black", col.background="white", title="EA Dimension 1 Correlation between Latent Variables") 

cor.test(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1]) 
plot_LV1$zeMap_background + plot_LV1$zeMap_dots + coord_cartesian()  # coord_cartesian stops plot 1:1 ratio


LV2 <- cbind(ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2])
colnames(LV2) <- c("Connectivity Latent Variable Scores", "Behavior Latent Variable Scores")
plot_LV2 <- createFactorMap(LV2, col.axes="black", col.background="white", title="EA Dimension 2 Correlation between Latent Variables") 

cor.test(ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2]) 
plot_LV2$zeMap_background + plot_LV2$zeMap_dots + coord_cartesian() 

```

```{r}
# component plots
factor <- rbind(ea_plsc$TExPosition.Data$fi, ea_plsc$TExPosition.Data$fj)
contributions <- rbind(ea_plsc$TExPosition.Data$ci, ea_plsc$TExPosition.Data$cj) # contribution reflected by size

# component plots with factor scores
#prettyPlot(factor, 
#           contributionCircles = TRUE,
#           contributions=contributions,
#           xlab='Component 1',
#           ylab='Component 2',
#           main='Component plot',
#           dev.new=F) #required so doesn't print list

# x connectivity set only
#prettyPlot(ea_plsc$TExPosition.Data$fi, 
#           contributionCircles = TRUE,
#           contributions=ea_plsc$TExPosition.Data$ci,
#           xlab='Component 1',
#           ylab='Component 2',
#           main='Component map X set', 
#           dev.new = F)

# y behavioural set only # can see some separation of soc and non-soc cog in component 2
prettyPlot(ea_plsc$TExPosition.Data$fj, 
           contributionCircles = TRUE,
           contributions=ea_plsc$TExPosition.Data$cj,
           xlab='Component 1',
           ylab='Component 2',
           main='Component map Y set', 
           dev.new = F)

```

```{r warning=FALSE}
# bootstrapping for contributor significance # critical val of 2.58 (alpha < .01 two-sided)
# bootstrapped model 
set.seed(999)
ea_plsc_boot <- Boot4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000,
  critical.value = 2.6, nf2keep = 3) 

BR_conn <- ea_plsc_boot$bootRatios.i
BR_beh <- ea_plsc_boot$bootRatios.j
rownames(BR_beh) <- c("RMET", "Emotion Recognition 40", "Empathic Accuracy", "TASIT 1", "T2 Sincere", 
                "T2 Simple Sarcasm", "T2 Paradoxical Sarcasm", "T3 Lies", "T3 Sarcasm", 
                "Processing Speed", "Attention/Vigilance", "Working Memory", 
                "Verbal Learning", "Visual Learning", "Reasoning & Problem Solving")

# sig conn for LC1 # 2129 w 2.6  
length(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))
#names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))

# sig beh for LC1  # 12 w 2.6
names(which(ea_plsc_boot$bootRatiosSignificant.j[,1] == TRUE))

# sig conn for LC2 # 244 w 2.6  
length(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))
#names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))

# sig beh for LC2 # 4 w 2.6
names(which(ea_plsc_boot$bootRatiosSignificant.j[,2] == TRUE))

```

```{r}
# RData saved here
#save.image(file = "/projects/loliver/SPINS_PLS_Conn/notebooks/EA_PLSC_subcor_combat_regresswFD_thresholded.RData")

```

```{r fig.height=6, fig.width=6}
# contribution plots
# contributions are absolute values, so need to get signs based on factor scores
Cx_conn <- ea_plsc$TExPosition.Data$ci * sign(ea_plsc$TExPosition.Data$fi)
Cy_beh <- ea_plsc$TExPosition.Data$cj * sign(ea_plsc$TExPosition.Data$fj)
rownames(Cy_beh) <- c("RMET", "Emotion Recognition 40", "Empathic Accuracy", "TASIT 1", "T2 Sincere", 
                "T2 Simple Sarcasm", "T2 Paradoxical Sarcasm", "T3 Lies", "T3 Sarcasm", 
                "Processing Speed", "Attention/Vigilance", "Working Memory", 
                "Verbal Learning", "Visual Learning", "Reasoning & Problem Solving")

# plot top 25 contributing conn vars 
top_25 <- names(sort(Cx_conn[,1], decreasing=TRUE)[1:25])
Cx_conn_top_25 <- Cx_conn[top_25,1]

cont_conn_plot_LC1  <- PrettyBarPlot2(
            bootratio = round(100000*Cx_conn_top_25), 
            threshold = 100000*(1/nrow(Cx_conn)),
            color4ns = "gray75", 
            #signifOnly = TRUE,
            plotnames = TRUE,
            main = 'EA Dimension 1: Contributions - Connectivity',
            ylab = 'Signed Contributions')

print(cont_conn_plot_LC1)

# Variables that contribute more than average (i.e., with a big enough effect size) are considered important (https://herveabdi.github.io/R4SPISE2022/articles/C1_PLSConWines.html#circles-of-correlations)
# When the variables are centered and scaled to have their sums of squares=1, each variable contributes one unit of variance; therefore, the average contribution is 1/(# of variables of the table)

cont_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = round(100*Cy_beh[,1]),
  threshold = 100*(1/15), 
  ylim=c(0, 14), # manually updated based on rounding
  #ylim=c(0, max(abs(100*Cy_beh[,1]))),
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE,
  #font.shrink = 0,
  font.size = 4,
  line.alpha = 1,
  #main = 'EA Dimension 1: Contributions - Behavior',
  ylab = 'Contributions') +
  scale_y_continuous(limits=c(0,14)) + # ylim wasn't restricting the range 
  theme(axis.title.y = element_text(size=13))

print(cont_beh_plot_LC1)

cont_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = round(100*Cy_beh[,2]),
  threshold = 100*(1/15),
  ylim=c(-32, max(100*Cy_beh[,2])),
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE,
  #font.shrink = 0,
  font.size = 4,
  line.alpha = 1,
  #main = 'EA Dimension 2: Contributions - Behavior',
  ylab = 'Contributions') +
  scale_y_continuous(limits=c(-32, max(100*Cy_beh[,2]))) +
  theme(axis.title.y = element_text(size=13))

print(cont_beh_plot_LC2)

```

```{r}
# bootstrap ratio plots

# beh for LC1
br_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = BR_beh[,1], # for LC1 
  threshold = 2.6, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE, 
  font.size = 4,
  line.alpha = 1,
  #main = 'EA Dimension 1: Bootstrap Ratios - Behavior', 
  ylab = "Bootstrap Ratios") +
  theme(axis.title.y = element_text(size=13))

print(br_beh_plot_LC1)

# beh for LC2
br_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = BR_beh[,2], # for LC2
  threshold = 2.6, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  color4ns = "gray75", 
  plotnames = TRUE, 
  font.size = 4,
  line.alpha = 1,
  #main = 'EA Dimension 2: Bootstrap Ratios - Behavior', 
  ylab = "Bootstrap Ratios") +
  theme(axis.title.y = element_text(size=13))

print(br_beh_plot_LC2)

```

```{r warning=FALSE}
# salience plots 
sal_conn <- ea_plsc$TExPosition.Data$pdq$p
sal_beh <- ea_plsc$TExPosition.Data$pdq$q

# conn for LC1
sal_conn_plot_LC1 <- PrettyBarPlot2(
  bootratio = sal_conn[,1], # for LC1 
  threshold = 0, 
  ylim = NULL, 
  color.bar = c("mediumpurple4", "darkolivegreen4", "gray75"),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  main = 'EA Dimension 1: Saliences - Connectivity', 
  ylab = "Saliences")

# beh for LC1
sal_beh_plot_LC1 <- PrettyBarPlot2(
  bootratio = sal_beh[,1], # for LC1 
  threshold = 0, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 1: Saliences - Behavior', 
  ylab = "Saliences")

print(sal_beh_plot_LC1)

# conn for LC2
sal_conn_plot_LC2 <- PrettyBarPlot2(
  bootratio = sal_conn[,2], # for LC2
  threshold = 0, 
  ylim = NULL, 
  color.bar = c("mediumpurple4", "darkolivegreen4", "gray75"),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  main = 'EA Dimension 2: Saliences - Connectivity', 
  ylab = "Saliences")

# beh for LC2
sal_beh_plot_LC2 <- PrettyBarPlot2(
  bootratio = sal_beh[,2], # for LC2
  threshold = 0, 
  ylim = NULL, 
  color4bar = c(rep("mediumpurple4",9),rep("darkolivegreen4",6)),
  #color4ns = "gray75", 
  plotnames = TRUE, 
  #font.size = 5,
  main = 'EA Dimension 2: Saliences - Behavior', 
  ylab = "Saliences")

print(sal_beh_plot_LC2)

```

```{r fig.height=5.75, fig.width=9}
# arrange LC1 and LC2 contribution and bootstrap ratio plots 
library(gridExtra)

# contributions and bootstrap ratios
LD1_beh <- grid.arrange(
    cont_beh_plot_LC1,
    br_beh_plot_LC1,
    ncol = 2,nrow = 1,
    top = "" #Behavior Contributions and Bootstrap Ratios EA Dimension 1"
  )


LD2_beh <- grid.arrange(
    cont_beh_plot_LC2,
    br_beh_plot_LC2,
    ncol = 2,nrow = 1,
    top = "" #Behavior Contributions and Bootstrap Ratios EA Dimension 2"
  )

```


```{r fig.height=6, fig.width=8}
# Visualize conn findings - saliences
net_cols <- c("darkolivegreen4","darkorange","brown","red","orchid2","gold","darkcyan","chartreuse","magenta4","cyan","purple","blue","black")

# Generate matrices with salience values (loadings) for sig contributors for LV1
ea_conn_sal_LV1 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F) # changed from sep="-" - confirmed retaining correct # of ROIs

# change r values to saliences for significant connections - the saliences are small values, hence the x100 for visualization
# divided by 4 to limit the range between 0 and 1 for plot alpha - check range()
ea_conn_sal_LV1[ea_conn_sal_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 100*(sal_conn[rownames(sal_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/4

# make all other connections 0
ea_conn_sal_LV1[!(ea_conn_sal_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# visualize LV1 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_sal_LV1 <- as_tbl_graph(ea_conn_sal_LV1[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# swirly plot by network
ggraph(tg_ea_conn_sal_LV1, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_sal_LV1, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

```

```{r fig.height=6, fig.width=8}
# Visualize conn findings - signed contributions
# Generate matrices with contribution values for sig contributors for LV1 
ea_conn_LV1 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to contributions for significant connections - the contributions are very small values, hence the x10000 for visualization
# divided by 12 to limit the range between 0 and 1 for plot alpha - check range() # kept the same as orig (vs 11) as just for visualization and similar 
ea_conn_LV1[ea_conn_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 10000*(Cx_conn[rownames(Cx_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/12

# make all other connections 0
ea_conn_LV1[!(ea_conn_LV1$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# visualize LV1 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_LV1 <- as_tbl_graph(ea_conn_LV1[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r > 0.1087 ~ "pos", r < -0.1087 ~ "neg", r <= 0.1087 & r >= -0.1087 ~ "ns"), r=abs(r)) %>% 
  filter(val != "ns") # updated to filter out vars deemed important (those that contribute more than average: 10000*(1/nrow(Cx_conn))/12
# was mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns")

# swirly plot by lobe
ggraph(tg_ea_conn_LV1, layout="linear", sort.by=lobe) +
  geom_edge_arc(aes(colour=val),alpha=.2) + # width=r
  geom_node_point(aes(colour=lobe), size=4) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# by network
ggraph(tg_ea_conn_LV1, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_LV1, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

```

```{r fig.height=6, fig.width=8}
# Visualize conn findings - original mean conn values multiplied by contribution
# Generate matrices with conn x contribution values for sig contributors for LV1
# remove roi column before calculating means across matrices
mean_ea_cor <- lapply(ea_cor, "[", 1:392, 2:393)

# get mean corrs across participants 
mean_ea_cor <- aaply(laply(mean_ea_cor, as.matrix), c(2, 3), mean, na.rm=F)

# corr plot
#rplot(mean_ea_cor)

detach(package:plyr)

# convert to tibble, add back roi column, rearrange columns, and convert to cor_df object
mean_ea_cor <- as_tibble(mean_ea_cor)
mean_ea_cor$term <- colnames(mean_ea_cor)
mean_ea_cor <- mean_ea_cor[1:392,c(393,1:392)]
mean_ea_cor <- as_cordf(mean_ea_cor)

# create df with mean corrs across participants
mean_ea_cor_str <- stretch(mean_ea_cor, na.rm=F) # the NAs will get changed to 0s anyway
mean_ea_conn_df <- unite(mean_ea_cor_str, col="rois", 1:2, sep=".", remove=F)

```

```{r}
# visualize positive and negative loadings separately to retain pos vs neg orig connectivity - conn direction by contribution
library(tidygraph)
library(ggraph)

# only retain conn direction, not magnitude
#mean_ea_conn_dir <- mean_ea_conn_df %>% mutate(r = case_when(r>0 ~ 1, r<0 ~ -1, r==0 ~ 0))

# multiply conn by absolute contribution ($ci)
ea_conn_cont_LV1_abs <- mean_ea_conn_df

ea_conn_cont_LV1_abs[ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"] <- 10000*sign(ea_conn_cont_LV1_abs[ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)), "r"])*(ea_plsc$TExPosition.Data$ci[rownames(ea_plsc$TExPosition.Data$ci) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE)),1])/12 

# make non-sig connections 0
ea_conn_cont_LV1_abs[!(ea_conn_cont_LV1_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,1] == TRUE))), "r"] <- 0

# make negative loadings 0 to visualize positive loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV1_pos <- ea_conn_cont_LV1_abs
ea_conn_cont_LV1_pos[ea_conn_cont_LV1_pos$rois %in% names(which(Cx_conn[,1]<0.0001305)), "r"] <- 0 # was <0 

# make positive loadings 0 to visualize negative loadings only, and those above contribution threshold
ea_conn_cont_LV1_neg <- ea_conn_cont_LV1_abs
ea_conn_cont_LV1_neg[ea_conn_cont_LV1_neg$rois %in% names(which(Cx_conn[,1]>-0.0001305)), "r"] <- 0 # was >0

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_pos <- as_tbl_graph(ea_conn_cont_LV1_pos[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig and pos nodes
tg_ea_conn_cont_LV1_neg <- as_tbl_graph(ea_conn_cont_LV1_neg[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# orig mean connectivity values > .4 (not just sig)
tg_ea_conn_LV1_r <- as_tbl_graph(mean_ea_conn_df[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns") %>% filter(abs(r) > .4)

```

```{r fig.height=6, fig.width=8}
# orig mean conn values > .4
ggraph(tg_ea_conn_LV1_r, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r), alpha=.3) +  
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1)) +
  ggtitle("Connectivity") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# positive loadings
ggraph(tg_ea_conn_cont_LV1_pos, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  #scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

data.frame(ea_conn_cont_LV1_pos[order(ea_conn_cont_LV1_pos$r, decreasing = TRUE),])

# negative loadings
ggraph(tg_ea_conn_cont_LV1_neg, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

data.frame(ea_conn_cont_LV1_neg[order(ea_conn_cont_LV1_neg$r, decreasing = TRUE),])

```


```{r}
# calculate mean within and between-network values for the contributions (sig only) - pos 
ea_conn_cont_LV1_pos_df <- data.frame(ea_conn_cont_LV1_pos)

# change duplicates to same value
ea_conn_cont_LV1_pos_dup <- data.frame(ea_conn_cont_LV1_pos[,2:4])
colnames(ea_conn_cont_LV1_pos_dup) <- c("y","x","r")
ea_conn_cont_LV1_pos_dup <- ea_conn_cont_LV1_pos_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV1_pos_dup <- ea_conn_cont_LV1_pos_dup[ea_conn_cont_LV1_pos_dup$r!=0,]

ea_conn_cont_LV1_pos_dup <- unite(ea_conn_cont_LV1_pos_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV1_pos_dup$rois) {
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$rois == i,"r"] <- ea_conn_cont_LV1_pos_dup[ea_conn_cont_LV1_pos_dup$rois == i, "r"]
}

# add forced roi names and orig order to roi df
rois$forced_name <- colnames(ea_cor[[1]][2:393])
rois$orig_order <- 1:392

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV1_pos_df[ea_conn_cont_LV1_pos_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values 
ea_conn_cont_LV1_pos_nets <- ea_conn_cont_LV1_pos_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),  # [r!=0] get mean of sig values only
            count=n())

ea_conn_cont_LV1_pos_nets$to <- as.factor(ea_conn_cont_LV1_pos_nets$to)
ea_conn_cont_LV1_pos_nets$from <- as.factor(ea_conn_cont_LV1_pos_nets$from)
#ea_conn_cont_LV1_pos_nets$mean[is.nan(ea_conn_cont_LV1_pos_nets$mean)] <- 0 # change NaNs to 0s

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_pos_nets <- as_tbl_graph(ea_conn_cont_LV1_pos_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")  # activate(nodes) %>% 
  #mutate(to=as.factor(ea_conn_cont_LV1_pos_nets$to),from=as.factor(ea_conn_cont_LV1_pos_nets$from)) %>%


# calculate mean within and between-network values for contributions (sig only) - neg 
ea_conn_cont_LV1_neg_df <- data.frame(ea_conn_cont_LV1_neg)

# change duplicates to same value
ea_conn_cont_LV1_neg_dup <- data.frame(ea_conn_cont_LV1_neg[,2:4])
colnames(ea_conn_cont_LV1_neg_dup) <- c("y","x","r")
ea_conn_cont_LV1_neg_dup <- ea_conn_cont_LV1_neg_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV1_neg_dup <- ea_conn_cont_LV1_neg_dup[ea_conn_cont_LV1_neg_dup$r!=0,]

ea_conn_cont_LV1_neg_dup <- unite(ea_conn_cont_LV1_neg_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV1_neg_dup$rois) {
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$rois == i,"r"] <- ea_conn_cont_LV1_neg_dup[ea_conn_cont_LV1_neg_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV1_neg_df[ea_conn_cont_LV1_neg_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values
ea_conn_cont_LV1_neg_nets <- ea_conn_cont_LV1_neg_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),
            count=n())
ea_conn_cont_LV1_neg_nets$to <- as.factor(ea_conn_cont_LV1_neg_nets$to)
ea_conn_cont_LV1_neg_nets$from <- as.factor(ea_conn_cont_LV1_neg_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV1_neg_nets <- as_tbl_graph(ea_conn_cont_LV1_neg_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")

```
```{r fig.height=6, fig.width=7.5}
# network list without numbers
net_names <- c("Orbito-Affective","Ventral-Multimodal","Posterior-Multimodal","Default","Auditory","Frontoparietal","Language","Dorsal-Attention",
               "Cingulo-Opercular","Somatomotor","Secondary Visual","Primary Visual","Subcortical")

# mean nets positive loadings (showing contribution)
nets_pos_LV1 <- ggraph(tg_ea_conn_cont_LV1_pos_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #, alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.3)) + 
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) +  #, alpha=.6
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) # plot.margin = unit(c(0, 1.5, 0, 1.5),"inches")) tried to stop labels getting cut

nets_pos_LV1 + geom_node_text(aes(label=net_names,colour=name,size=3.5), nudge_x=.12, nudge_y=-.14, show.legend=F)

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD1_nets_pos.png", device = "png", height=6, width=7.5)

data.frame(ea_conn_cont_LV1_pos_nets[order(ea_conn_cont_LV1_pos_nets$mean, decreasing = TRUE),])

# mean nets negative loadings
nets_neg_LV1 <- ggraph(tg_ea_conn_cont_LV1_neg_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) +  #, alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) + # shape=15, 
  #geom_node_label(aes(label=name, colour=name), size = 6, show.legend=F) +
  #geom_node_text(aes(label=name),  colour='black', size=4,
  #                show.legend=FALSE, family="mono") +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.03)) +
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) + #, alpha=.6
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_neg_LV1 + geom_node_text(aes(label=net_names,colour=name,size=3.5), nudge_x=.12, nudge_y=-.14, show.legend=F) 
# geom_node_text(aes(label=net_names,colour=name,size=5), show.legend=F, nudge_x=nets_neg_LV1$data$x*.4, nudge_y=nets_neg_LV1$data$y*.2) 

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD1_nets_neg.png", device = "png", height=6, width=7.5)

data.frame(ea_conn_cont_LV1_neg_nets[order(ea_conn_cont_LV1_neg_nets$mean, decreasing = TRUE),])

```

```{r, fig.height=5, fig.width=6.5}
# heatmap mean nets pos loadings (contribution) - I think these make the most sense to display (doesn't remove something just because non-sig)
ggplot(ea_conn_cont_LV1_pos_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "black") +
  geom_tile(data = ea_conn_cont_LV1_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .5) +
  #scale_fill_gradient(high = "#2166ac", low = "white", limit = c(0,.3), name="") + 
  scale_fill_continuous_sequential(palette = "Oslo", rev=F, begin=0, end=1, l1=100, name="Contribution") + #l1=100 = white
  scale_x_discrete(labels=net_names) + scale_y_discrete(labels=net_names) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.4, size = 12),
        axis.text = element_text(size = 12, color=net_cols)) + ylab("") + xlab("")
  #ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD1_reg_heat_nets_pos_mean.png", device = "png", height=5, width=6.5)

options(scipen = 999) # added as neg legend was showing values in scientific notation

# neg loadings
ggplot(ea_conn_cont_LV1_neg_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "black") +
  geom_tile(data = ea_conn_cont_LV1_neg_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .5) +
  scale_fill_continuous_sequential(palette = "Oslo", rev=F, begin=0, end=0.3, l1=100, name="Contribution") +
  scale_x_discrete(labels=net_names) + scale_y_discrete(labels=net_names) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.4, size = 12),
        axis.text = element_text(size = 12, color=net_cols)) + ylab("") + xlab("")
  #ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD1_reg_heat_nets_neg_mean.png", device = "png", height=5, width=6.5)

```


```{r fig.height=6, fig.width=8}
# LV2 saliences
# Generate matrices with salience values (loadings) for sig contributors for LV2
ea_conn_sal_LV2 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to saliences for significant connections - the salience are small values, hence the x100 for visualization
# divided by 4 to limit the range between 0 and 1 for plot alpha - check range()
ea_conn_sal_LV2[ea_conn_sal_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 100*(sal_conn[rownames(sal_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/4

# make all other connections 0
ea_conn_sal_LV2[!(ea_conn_sal_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# visualize LV2 conn results
library(tidygraph)
library(ggraph)

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
# added the numbers to neg and pos to change colour order # net_order_ColeAnt includes network number
tg_ea_conn_sal_LV2 <- as_tbl_graph(ea_conn_sal_LV2[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# swirly plot by network
ggraph(tg_ea_conn_sal_LV2, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_sal_LV2, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

```

```{r fig.height=6, fig.width=8}
# LV2 signed contributions
ea_conn_LV2 <- unite(ea_cor_str[[1]], col="rois", 1:2, sep=".", remove=F)

# change r values to saliences for significant connections # changed to 16
ea_conn_LV2[ea_conn_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 10000*(Cx_conn[rownames(Cx_conn) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/16

# make all other connections 0
ea_conn_LV2[!(ea_conn_LV2$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# visualize LV2 conn results
# convert to tbl_graph tidygraph object and add other node info - filter out non-sig nodes
tg_ea_conn_LV2 <- as_tbl_graph(ea_conn_LV2[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   # could change to area if update
  activate(edges) %>% mutate(val = case_when(r > 0.082 ~ "pos", r < -0.082 ~ "neg", r <= 0.082 & r >= -0.082 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")
# updated to filter out vars deemed important (those that contribute more than average: 10000*(1/nrow(Cx_conn))/16
# was mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns")

# swirly plot by network
ggraph(tg_ea_conn_LV2, layout="linear", sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=0.3) + 
  geom_node_point(aes(colour=Network), size = 2) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() +  
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x  = element_blank(),
        axis.text.y  = element_blank()) 

# circle plot by network
ggraph(tg_ea_conn_LV2, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=0.3) +   #,curvature=sign(strength$r)
  geom_node_point(aes(colour=Network), size = 4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_width_continuous(range = c(0,1)) +
  theme_minimal() +  
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x  = element_blank(),
        axis.text.y  = element_blank())  

```

```{r}
# generate matrices with conn x contribution values for sig contributors for LV2
# visualize positive and negative loadings separately to retain pos vs neg orig connectivity - contribution
library(tidygraph)
library(ggraph)

# multiply conn by absolute loading ($ci)
ea_conn_cont_LV2_abs <- mean_ea_conn_df
ea_conn_cont_LV2_abs[ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"] <- 10000*sign(ea_conn_cont_LV2_abs[ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)), "r"])*(ea_plsc$TExPosition.Data$ci[rownames(ea_plsc$TExPosition.Data$ci) %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE)),2])/15

# make non-sig connections 0
ea_conn_cont_LV2_abs[!(ea_conn_cont_LV2_abs$rois %in% names(which(ea_plsc_boot$bootRatiosSignificant.i[,2] == TRUE))), "r"] <- 0

# make negative loadings 0 to visualize positive loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV2_pos <- ea_conn_cont_LV2_abs
ea_conn_cont_LV2_pos[ea_conn_cont_LV2_pos$rois %in% names(which(Cx_conn[,2]<0.0001305)), "r"] <- 0 # was <0

# make positive loadings  0 to visualize negative loadings only, and those below contribution threshold (1/nrow(Cx_conn))
ea_conn_cont_LV2_neg <- ea_conn_cont_LV2_abs
ea_conn_cont_LV2_neg[ea_conn_cont_LV2_neg$rois %in% names(which(Cx_conn[,2]>-0.0001305)), "r"] <- 0 # was >0

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_pos <- as_tbl_graph(ea_conn_cont_LV2_pos[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>%   
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

# convert to tbl_graph tidygraph object and add other node info - filter out non-sig and pos nodes
tg_ea_conn_cont_LV2_neg <- as_tbl_graph(ea_conn_cont_LV2_neg[,2:4], directed=F) %>% activate(nodes) %>% 
  mutate(roi=rois$name, lobe=as.factor(rois$lobe), Network=as.factor(rois$net_order_ColeAnt), 
  hemi=as.factor(rois$hemi), region=as.factor(rois$region)) %>% 
  activate(edges) %>% mutate(val = case_when(r>0 ~ "pos", r<0 ~ "neg", r==0 ~ "ns"), r=abs(r)) %>%
  filter(val != "ns")

```

```{r fig.height=6, fig.width=8}
# positive loadings
ggraph(tg_ea_conn_cont_LV2_pos, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Positive Loadings") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

# negative loadings
ggraph(tg_ea_conn_cont_LV2_neg, layout="linear", circular=T, sort.by=Network) +
  geom_edge_arc(aes(colour=val,width=r),alpha=.3) + 
  geom_node_point(aes(colour=Network), size=4) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,1)) +
  ggtitle("Negative Loadings") +
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

```

```{r}
# calculate mean within and between-network values for the contributions (sig only) - pos 
ea_conn_cont_LV2_pos_df <- data.frame(ea_conn_cont_LV2_pos)

# change duplicates to same value
ea_conn_cont_LV2_pos_dup <- data.frame(ea_conn_cont_LV2_pos[,2:4])
colnames(ea_conn_cont_LV2_pos_dup) <- c("y","x","r")
ea_conn_cont_LV2_pos_dup <- ea_conn_cont_LV2_pos_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV2_pos_dup <- ea_conn_cont_LV2_pos_dup[ea_conn_cont_LV2_pos_dup$r!=0,]

ea_conn_cont_LV2_pos_dup <- unite(ea_conn_cont_LV2_pos_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV2_pos_dup$rois) {
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$rois == i,"r"] <- ea_conn_cont_LV2_pos_dup[ea_conn_cont_LV2_pos_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV2_pos_df[ea_conn_cont_LV2_pos_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values 
ea_conn_cont_LV2_pos_nets <- ea_conn_cont_LV2_pos_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),  # [r!=0] get mean of sig values only
            count=n())

ea_conn_cont_LV2_pos_nets$to <- as.factor(ea_conn_cont_LV2_pos_nets$to)
ea_conn_cont_LV2_pos_nets$from <- as.factor(ea_conn_cont_LV2_pos_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_pos_nets <- as_tbl_graph(ea_conn_cont_LV2_pos_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")  


# calculate mean within and between-network values for contributions (sig only) - neg 
ea_conn_cont_LV2_neg_df <- data.frame(ea_conn_cont_LV2_neg)

# change duplicates to same value
ea_conn_cont_LV2_neg_dup <- data.frame(ea_conn_cont_LV2_neg[,2:4])
colnames(ea_conn_cont_LV2_neg_dup) <- c("y","x","r")
ea_conn_cont_LV2_neg_dup <- ea_conn_cont_LV2_neg_dup[,c(2,1,3)]

# filter out 0 values
ea_conn_cont_LV2_neg_dup <- ea_conn_cont_LV2_neg_dup[ea_conn_cont_LV2_neg_dup$r!=0,]

ea_conn_cont_LV2_neg_dup <- unite(ea_conn_cont_LV2_neg_dup, col="rois", 1:2, sep=".", remove=F)

# replace duplicate 0s with sig contribution values
for (i in ea_conn_cont_LV2_neg_dup$rois) {
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$rois == i,"r"] <- ea_conn_cont_LV2_neg_dup[ea_conn_cont_LV2_neg_dup$rois == i, "r"]
}

# add networks for each ROI
for (i in rois$forced_name) {
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$x==i,"to"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
  ea_conn_cont_LV2_neg_df[ea_conn_cont_LV2_neg_df$y==i,"from"] <- rois[rois$forced_name==i,"net_order_ColeAnt"]
}

# get mean within and between network values
ea_conn_cont_LV2_neg_nets <- ea_conn_cont_LV2_neg_df %>%
  group_by(to, from) %>%
  summarise(mean=mean(r),
            count=n())
ea_conn_cont_LV2_neg_nets$to <- as.factor(ea_conn_cont_LV2_neg_nets$to)
ea_conn_cont_LV2_neg_nets$from <- as.factor(ea_conn_cont_LV2_neg_nets$from)

# convert to tbl_graph tidygraph object and add other node info 
tg_ea_conn_cont_LV2_neg_nets <- as_tbl_graph(ea_conn_cont_LV2_neg_nets[,1:3], directed=F) %>%    
  activate(edges) %>% mutate(val = case_when(mean>0 ~ "pos", mean<0 ~ "neg", mean==0 ~ "ns"), mean=abs(mean)) %>%
  filter(val != "ns")

```

```{r fig.height=6.5, fig.width=8}
# mean nets positive loadings (contributions)
nets_pos_LV2 <- ggraph(tg_ea_conn_cont_LV2_pos_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #,alpha=.6
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.1)) +
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) + #, alpha=.6
  ggtitle("Positive Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_pos_LV2 + geom_node_text(aes(label=net_names,colour=name,size=3.5), nudge_x=.12, nudge_y=-.14, show.legend=F)

data.frame(ea_conn_cont_LV2_pos_nets[order(ea_conn_cont_LV2_pos_nets$mean, decreasing = TRUE),])

# mean nets negative loadings
nets_neg_LV2 <- ggraph(tg_ea_conn_cont_LV2_neg_nets, layout="linear", circular=T, sort.by=name) +
  geom_edge_arc(aes(colour=val,width=mean), show.legend=F) + #,alpha=.6,
  geom_node_point(aes(colour=name), size=6, show.legend=F) +
  scale_colour_manual(values=net_cols) +
  scale_edge_color_manual(values="#00BFC4") + # added because connections all positive
  scale_edge_width_continuous(range = c(0,1), limits = c(0,.01)) +
  geom_edge_loop(aes(colour=val, width=mean, span=90, direction=360)) +  #, alpha=.6
  ggtitle("Negative Loadings") + 
  theme_minimal() + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) 

nets_neg_LV2 + geom_node_text(aes(label=net_names,colour=name,size=3.5), nudge_x=.12, nudge_y=-.14, show.legend=F)
# geom_node_text(aes(label=name,colour=name), show.legend=F, nudge_x=nets_neg_LV2$data$x*.4, nudge_y=nets_neg_LV2$data$y*.2) 

data.frame(ea_conn_cont_LV2_neg_nets[order(ea_conn_cont_LV2_neg_nets$mean, decreasing = TRUE),])

```

```{r, fig.height=5, fig.width=6.5}
# heatmap mean nets pos loadings (contribution)
ggplot(ea_conn_cont_LV2_pos_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "black") +
  geom_tile(data = ea_conn_cont_LV2_pos_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .5) +
  scale_fill_continuous_sequential(palette = "Oslo", rev=F, begin=0, end=0.4, l1=100, name="Contribution") + #l1=100 = white
  scale_x_discrete(labels=net_names) + scale_y_discrete(labels=net_names) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.4, size = 12),
        axis.text = element_text(size = 12, color=net_cols)) + ylab("") + xlab("")
  #ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD2_reg_heat_nets_pos_mean.png", device = "png", height=5, width=6.5)


# neg loadings
ggplot(ea_conn_cont_LV2_neg_nets, aes(x=from,y=to,fill=mean)) + 
  geom_tile(color = "black") +
  geom_tile(data = ea_conn_cont_LV2_neg_nets[c(1,15,29,43,57,71,85,99,113,127,141,155,169),], fill = NA, color = "black", size = .5) +
  scale_fill_continuous_sequential(palette = "Oslo", rev=F, begin=0, end=0.25, l1=100, name="Contribution") +
  scale_x_discrete(labels=net_names) + scale_y_discrete(labels=net_names) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.4, size = 12),
        axis.text = element_text(size = 12, color=net_cols)) + ylab("") + xlab("")
  #ggtitle("Mean Within and Between-Network Contributions") + ylab("") + xlab("")

#ggsave(filename="/projects/loliver/SPINS_PLS_Conn/reports/figures/EA_LD2_reg_heat_nets_neg_mean.png", device = "png", height=5, width=6.5)

```

```{r warning=FALSE}
# PLSC by diagnostic group (results are the same as above, we will just examine them by group)
ea_plsc_gr <- tepPLS(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN=spins_behav_combat$diagnostic_group, graphs=FALSE)

# permutation testing and scree plot to determine number of components
set.seed(999)
perm_ea_plsc_gr <- perm4PLSC(conn, beh, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", nIter = 1000) 

ea_plsc_gr$TExPosition.Data$t # to get variance explained
perm_ea_plsc_gr$pEigenvalues # to get LV p values

```

```{r warning=FALSE}
# plot scores 
LV1_gr <- cbind(ea_plsc_gr$TExPosition.Data$lx[,1],ea_plsc_gr$TExPosition.Data$ly[,1])
colnames(LV1_gr) <- c("Lx_conn 1", "Ly_beh 1")
rownames(LV1_gr) <- spins_behav_combat$diagnostic_group

# compute LV1 group means 
LV1_gr_mean <- getMeans(LV1_gr, spins_behav_combat$diagnostic_group)
rownames(LV1_gr_mean) <- c("case", "control")
colnames(LV1_gr_mean) <- c("Lx_conn 1", "Ly_beh 1")

# colours by group means
gr_colours <- dplyr::recode(rownames(LV1_gr),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV1_gr_mean),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV1_gr_mean_boot <- Boot4Mean(LV1_gr, spins_behav_combat$diagnostic_group)

# add colnames to array
colnames(ea_LV1_gr_mean_boot$BootCube) <- colnames(LV1_gr)

```

```{r warning=FALSE, fig.height=4.5, fig.width=6}
# plot LV1_gr
plot_LV1_gr <- createFactorMap(LV1_gr,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.3,
                         col.axes="black", 
                         col.background="white")

plot_LV1_gr_mean <- createFactorMap(LV1_gr_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              alpha.labels=0,
                              cex = 4.5,
                              pch = 17,
                              alpha.points = 0.8) 

plot_LV1_gr_meanCI <- MakeCIEllipses(ea_LV1_gr_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = as.matrix(gr_mean_colours),
                              names.of.factors = c("Lx_conn 1", "Ly_beh 1"))
                              
                         
cor.test(LV1_gr[rownames(LV1_gr)=="case","Lx_conn 1"],LV1_gr[rownames(LV1_gr)=="case","Ly_beh 1"]) # case r=.291, p<.0001
cor.test(LV1_gr[rownames(LV1_gr)=="control","Lx_conn 1"],LV1_gr[rownames(LV1_gr)=="control","Ly_beh 1"]) # control r=.159, p=.046
p.adjust(c(0.000000002899,0.01937), method = "fdr", n = 2)

plot1_LV1_gr <- plot_LV1_gr$zeMap_background + 
  plot_LV1_gr$zeMap_dots + 
  plot_LV1_gr_mean$zeMap_dots + 
  plot_LV1_gr_mean$zeMap_text +
  plot_LV1_gr_meanCI +
  coord_cartesian(xlim=c(-4.5, 5), ylim=c(-0.5, 0.3)) + 
  ggtitle("EA Dimension 1: Latent Variable Scores by Diagnostic Group") +
         labs(y = "Behavior Scores", x = "Connectivity Scores")

print(plot1_LV1_gr)

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for conn scores
LV1_gr_demo <- data.frame(cbind(LV1_gr,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.1 ~ diagnostic_group, data=LV1_gr_demo, paired=F)

# confirmed this is identical in model without design by group 

# plot scores by group
ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Lx_conn.1, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Connectivity Scores", x="SSD                     Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("#00BFC4","#8494FF")) + # maybe change colours #00AFBB
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Lx_conn.1, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Connectivity Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())


```

```{r fig.height=4, fig.width=5.5}
# t-tests by diagnostic group for beh scores
t.test(Ly_beh.1 ~ diagnostic_group, data=LV1_gr_demo, paired=F)

p.adjust(c(.00000,.00000), method = "fdr", n = 2)

# plot scores by group
ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Ly_beh.1, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Behavior Scores", x="SSD                       Control") +
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV1_gr_demo, aes( x= diagnostic_group, y = Ly_beh.1, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Behavior Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```


```{r warning=FALSE}
# plot LV2 scores 
LV2_gr <- cbind(ea_plsc_gr$TExPosition.Data$lx[,2],ea_plsc_gr$TExPosition.Data$ly[,2])
colnames(LV2_gr) <- c("Lx_conn 2", "Ly_beh 2")
rownames(LV2_gr) <- spins_behav_combat$diagnostic_group

# compute LV2 group means 
LV2_gr_mean <- getMeans(LV2_gr, spins_behav_combat$diagnostic_group)
rownames(LV2_gr_mean) <- c("case", "control")
colnames(LV2_gr_mean) <- c("Lx_conn 2", "Ly_beh 2")

# colours by group means
gr_colours <- dplyr::recode(rownames(LV2_gr),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

gr_mean_colours <- dplyr::recode(rownames(LV2_gr_mean),
                       'case' = '#F8766D',
                       'control' = '#00BFC4')

# get bootstrap intervals of groups
set.seed(999)
ea_LV2_gr_mean_boot <- Boot4Mean(LV2_gr, spins_behav_combat$diagnostic_group)

# add colnames to array
colnames(ea_LV2_gr_mean_boot$BootCube) <- colnames(LV2_gr)

```


```{r warning=FALSE, fig.height=4.5, fig.width=6}
# plot LV2_gr
plot_LV2_gr <- createFactorMap(LV2_gr,
                         col.points = gr_colours,
                         col.labels = gr_colours,
                         alpha.points = 0.3,
                         col.axes="black", 
                         col.background="white")

plot_LV2_gr_mean <- createFactorMap(LV2_gr_mean,
                              col.points = gr_mean_colours,
                              col.labels = gr_mean_colours,
                              alpha.labels=0,
                              cex = 4.5,
                              pch = 17,
                              alpha.points = 0.8)

plot_LV2_gr_meanCI <- MakeCIEllipses(ea_LV2_gr_mean_boot$BootCube[,c(1:2),], # get the first two components
                              col = gr_mean_colours,
                              names.of.factors = c("Lx_conn 2", "Ly_beh 2"))
                              
                         
cor.test(LV2_gr[rownames(LV2_gr)=="case","Lx_conn 2"],LV2_gr[rownames(LV2_gr)=="case","Ly_beh 2"]) # case r=.377, p<.0001
cor.test(LV2_gr[rownames(LV2_gr)=="control","Lx_conn 2"],LV2_gr[rownames(LV2_gr)=="control","Ly_beh 2"]) # control r=.464, p<.0001
p.adjust(c(.000035,0.00041), method = "fdr", n = 2)
  
plot1_LV2_gr <- plot_LV2_gr$zeMap_background + 
  plot_LV2_gr$zeMap_dots + 
  plot_LV2_gr_mean$zeMap_dots + 
  plot_LV2_gr_mean$zeMap_text +
  plot_LV2_gr_meanCI +
  coord_cartesian(xlim=c(-3, 5.5), ylim=c(-0.2, 0.25)) +
  ggtitle("EA Dimension 2: Latent Variable Scores by Diagnostic Group") +
         labs(y = "Behavior", x = "Connectivity")

print(plot1_LV2_gr)

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for conn scores
LV2_gr_demo <- data.frame(cbind(LV2_gr,spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

t.test(Lx_conn.2 ~ diagnostic_group, data=LV2_gr_demo, paired=F)

# plot scores by group
ggplot(LV2_gr_demo, aes( x = diagnostic_group, y = Lx_conn.2, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Connectivity Scores", x="SSD                          Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV2_gr_demo, aes( x = diagnostic_group, y = Lx_conn.2, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Connectivity Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```

```{r fig.height=4, fig.width=5}
# t-tests by diagnostic group for beh scores
t.test(Ly_beh.2 ~ diagnostic_group, data=LV2_gr_demo, paired=F)

p.adjust(c(.198,.146), method = "fdr", n = 2)

# plot scores by group
ggplot(LV2_gr_demo, aes( x= diagnostic_group, y = Ly_beh.2, col = diagnostic_group)) +
  geom_boxplot() + labs(y = "Behavior Scores", x="SSD                            Control") + 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
  #scale_fill_manual(values = c("blue","red")) +
  #facet_wrap(~valence,scales='free') +
  theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank())

ggplot(LV2_gr_demo, aes( x= diagnostic_group, y = Ly_beh.2, fill = diagnostic_group)) + 
     geom_boxplot(alpha = 0.4) + 
     geom_dotplot(binaxis = 'y', stackdir = 'center', alpha = 0.7, dotsize=.5) +
     #geom_hline(yintercept = 0) +
     labs(y = "Behavior Scores", x="SSD                     Control") +
     #scale_fill_manual(values = c("blue","red")) +
     theme_bw() +
     theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(),
           axis.text.x = element_blank())

```


```{r}
# control analyses - check for associations between scores and confounds
# add scores to demo data
LV_demo <- data.frame(cbind(ea_plsc$TExPosition.Data$lx[,1],ea_plsc$TExPosition.Data$ly[,1],ea_plsc$TExPosition.Data$lx[,2],ea_plsc$TExPosition.Data$ly[,2],spins_behav_combat[,c("record_id","diagnostic_group","demo_sex","demo_age_study_entry")]))

colnames(LV_demo)[1:4] <- c("Lx_conn.1","Ly_beh.1","Lx_conn.2","Ly_beh.2")

# add ea mean FD data
spins_fd <- read.csv(file="/projects/loliver/QC/spins_mean_fd_per_run.csv",stringsAsFactors=F,header=T)
LV_demo <- merge(LV_demo,spins_fd[,c("record_id","fd_mean.task.emp_bold")],by="record_id")

# correlations between scores and age and mean FD 
rcorr(as.matrix(LV_demo[,c(2:5,8:9)])) 

# t-tests for sex # all NS p=1
t.test(Lx_conn.1 ~ demo_sex, data=LV_demo, paired=F)
t.test(Ly_beh.1 ~ demo_sex, data=LV_demo, paired=F)

t.test(Lx_conn.2 ~ demo_sex, data=LV_demo, paired=F)
t.test(Ly_beh.2 ~ demo_sex, data=LV_demo, paired=F)

```

```{r}
# visualize associations

# Dimension 1
ggplot(LV_demo, aes(x=Lx_conn.1, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.1, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo, aes(x=Lx_conn.1, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.1, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

# Dimension 2
ggplot(LV_demo, aes(x=Lx_conn.2, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.2, y=demo_age_study_entry, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 
  
ggplot(LV_demo, aes(x=Lx_conn.2, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 

ggplot(LV_demo, aes(x=Ly_beh.2, y=fd_mean.task.emp_bold, col=diagnostic_group)) + 
  geom_point() + 
  geom_smooth(method="lm", fill="grey40") + 
  theme_bw() 
  
```

```{r}
# examine correlations between scores from orig model and this regressed model

# add orig scores to demo data
ea_orig_scores <- read.csv(file="/projects/loliver/SPINS_PLS_Conn/data/processed/spins_ea_plsc_scores.csv",stringsAsFactors=F,header=T)
LV_demo <- merge(LV_demo,ea_orig_scores[,c("record_id","Lx_conn.1","Ly_beh.1","Lx_conn.2","Ly_beh.2")],by="record_id")

# correlations between orig and new scores 
rcorr(as.matrix(LV_demo[,c(2:5,10:13)]))

```

